using itk.simple;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace ReidImaging.Common.ITK;
/// <summary>
/// Provides SimpleITK methods as extensions. Some are not included as it makes littler sense to have them as an extension
/// </summary>
public static class SimpleITKExtensionMethods
{
   public static Image Abs(this Image image1) => SimpleITK.Abs(image1);
   public static Image AbsoluteValueDifference(this double constant, Image image2) => SimpleITK.AbsoluteValueDifference(constant, image2);
   public static Image AbsoluteValueDifference(this Image image1, double constant) => SimpleITK.AbsoluteValueDifference(image1, constant);
   public static Image AbsoluteValueDifference(this Image image1, Image image2) => SimpleITK.AbsoluteValueDifference(image1, image2);
   public static Image Acos(this Image image1) => SimpleITK.Acos(image1);
   public static Image AdaptiveHistogramEqualization(this Image image1) => SimpleITK.AdaptiveHistogramEqualization(image1);
   public static Image AdaptiveHistogramEqualization(this Image image1, VectorUInt32 radius) => SimpleITK.AdaptiveHistogramEqualization(image1, radius);
   public static Image AdaptiveHistogramEqualization(this Image image1, VectorUInt32 radius, float alpha) => SimpleITK.AdaptiveHistogramEqualization(image1, radius, alpha);
   public static Image AdaptiveHistogramEqualization(this Image image1, VectorUInt32 radius, float alpha, float beta) => SimpleITK.AdaptiveHistogramEqualization(image1, radius, alpha, beta);
   public static Image Add(this double constant, Image image2) => SimpleITK.Add(constant, image2);
   public static Image Add(this Image image1, double constant) => SimpleITK.Add(image1, constant);
   public static Image Add(this Image image1, Image image2) => SimpleITK.Add(image1, image2);
   public static Image AdditiveGaussianNoise(this Image image1) => SimpleITK.AdditiveGaussianNoise(image1);
   public static Image AdditiveGaussianNoise(this Image image1, double standardDeviation) => SimpleITK.AdditiveGaussianNoise(image1, standardDeviation);
   public static Image AdditiveGaussianNoise(this Image image1, double standardDeviation, double mean) => SimpleITK.AdditiveGaussianNoise(image1, standardDeviation, mean);
   public static Image AdditiveGaussianNoise(this Image image1, double standardDeviation, double mean, uint seed) => SimpleITK.AdditiveGaussianNoise(image1, standardDeviation, mean, seed);
   public static Image AggregateLabelMap(this Image image1) => SimpleITK.AggregateLabelMap(image1);
   public static Image And(this Image image1, Image image2) => SimpleITK.And(image1, image2);
   public static Image And(this Image image1, int constant) => SimpleITK.And(image1, constant);
   public static Image And(this int constant, Image image2) => SimpleITK.And(constant, image2);
   public static Image AntiAliasBinary(this Image image1) => SimpleITK.AntiAliasBinary(image1);
   public static Image AntiAliasBinary(this Image image1, double maximumRMSError) => SimpleITK.AntiAliasBinary(image1, maximumRMSError);
   public static Image AntiAliasBinary(this Image image1, double maximumRMSError, uint numberOfIterations) => SimpleITK.AntiAliasBinary(image1, maximumRMSError, numberOfIterations);
   public static Image ApproximateSignedDistanceMap(this Image image1) => SimpleITK.ApproximateSignedDistanceMap(image1);
   public static Image ApproximateSignedDistanceMap(this Image image1, double insideValue) => SimpleITK.ApproximateSignedDistanceMap(image1, insideValue);
   public static Image ApproximateSignedDistanceMap(this Image image1, double insideValue, double outsideValue) => SimpleITK.ApproximateSignedDistanceMap(image1, insideValue, outsideValue);
   public static Image AreaClosing(this Image image1) => SimpleITK.AreaClosing(image1);
   public static Image AreaClosing(this Image image1, double lambda) => SimpleITK.AreaClosing(image1, lambda);
   public static Image AreaClosing(this Image image1, double lambda, bool useImageSpacing) => SimpleITK.AreaClosing(image1, lambda, useImageSpacing);
   public static Image AreaClosing(this Image image1, double lambda, bool useImageSpacing, bool fullyConnected) => SimpleITK.AreaClosing(image1, lambda, useImageSpacing, fullyConnected);
   public static Image AreaOpening(this Image image1) => SimpleITK.AreaOpening(image1);
   public static Image AreaOpening(this Image image1, double lambda) => SimpleITK.AreaOpening(image1, lambda);
   public static Image AreaOpening(this Image image1, double lambda, bool useImageSpacing) => SimpleITK.AreaOpening(image1, lambda, useImageSpacing);
   public static Image AreaOpening(this Image image1, double lambda, bool useImageSpacing, bool fullyConnected) => SimpleITK.AreaOpening(image1, lambda, useImageSpacing, fullyConnected);
   public static Image Asin(this Image image1) => SimpleITK.Asin(image1);
   public static Image Atan(this Image image1) => SimpleITK.Atan(image1);
   public static Image Atan2(this double constant, Image image2) => SimpleITK.Atan2(constant, image2);
   public static Image Atan2(this Image image1, double constant) => SimpleITK.Atan2(image1, constant);
   public static Image Atan2(this Image image1, Image image2) => SimpleITK.Atan2(image1, image2);
   public static Image Bilateral(this Image image1) => SimpleITK.Bilateral(image1);
   public static Image Bilateral(this Image image1, double domainSigma) => SimpleITK.Bilateral(image1, domainSigma);
   public static Image Bilateral(this Image image1, double domainSigma, double rangeSigma) => SimpleITK.Bilateral(image1, domainSigma, rangeSigma);
   public static Image Bilateral(this Image image1, double domainSigma, double rangeSigma, uint numberOfRangeGaussianSamples) => SimpleITK.Bilateral(image1, domainSigma, rangeSigma, numberOfRangeGaussianSamples);
   public static Image BinaryClosingByReconstruction(this Image image1) => SimpleITK.BinaryClosingByReconstruction(image1);
   public static Image BinaryClosingByReconstruction(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.BinaryClosingByReconstruction(image1, kernelRadius);
   public static Image BinaryClosingByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.BinaryClosingByReconstruction(image1, kernelRadius, kernelType);
   public static Image BinaryClosingByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double foregroundValue) => SimpleITK.BinaryClosingByReconstruction(image1, kernelRadius, kernelType, foregroundValue);
   public static Image BinaryClosingByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double foregroundValue, bool fullyConnected) => SimpleITK.BinaryClosingByReconstruction(image1, kernelRadius, kernelType, foregroundValue, fullyConnected);
   public static Image BinaryContour(this Image image1) => SimpleITK.BinaryContour(image1);
   public static Image BinaryContour(this Image image1, bool fullyConnected) => SimpleITK.BinaryContour(image1, fullyConnected);
   public static Image BinaryContour(this Image image1, bool fullyConnected, double backgroundValue) => SimpleITK.BinaryContour(image1, fullyConnected, backgroundValue);
   public static Image BinaryContour(this Image image1, bool fullyConnected, double backgroundValue, double foregroundValue) => SimpleITK.BinaryContour(image1, fullyConnected, backgroundValue, foregroundValue);
   public static Image BinaryDilate(this Image image1) => SimpleITK.BinaryDilate(image1);
   public static Image BinaryDilate(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.BinaryDilate(image1, kernelRadius);
   public static Image BinaryDilate(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.BinaryDilate(image1, kernelRadius, kernelType);
   public static Image BinaryDilate(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double backgroundValue) => SimpleITK.BinaryDilate(image1, kernelRadius, kernelType, backgroundValue);
   public static Image BinaryDilate(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double backgroundValue, double foregroundValue) => SimpleITK.BinaryDilate(image1, kernelRadius, kernelType, backgroundValue, foregroundValue);
   public static Image BinaryDilate(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double backgroundValue, double foregroundValue, bool boundaryToForeground) => SimpleITK.BinaryDilate(image1, kernelRadius, kernelType, backgroundValue, foregroundValue, boundaryToForeground);
   public static Image BinaryErode(this Image image1) => SimpleITK.BinaryErode(image1);
   public static Image BinaryErode(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.BinaryErode(image1, kernelRadius);
   public static Image BinaryErode(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.BinaryErode(image1, kernelRadius, kernelType);
   public static Image BinaryErode(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double backgroundValue) => SimpleITK.BinaryErode(image1, kernelRadius, kernelType, backgroundValue);
   public static Image BinaryErode(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double backgroundValue, double foregroundValue) => SimpleITK.BinaryErode(image1, kernelRadius, kernelType, backgroundValue, foregroundValue);
   public static Image BinaryErode(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double backgroundValue, double foregroundValue, bool boundaryToForeground) => SimpleITK.BinaryErode(image1, kernelRadius, kernelType, backgroundValue, foregroundValue, boundaryToForeground);
   public static Image BinaryFillhole(this Image image1) => SimpleITK.BinaryFillhole(image1);
   public static Image BinaryFillhole(this Image image1, bool fullyConnected) => SimpleITK.BinaryFillhole(image1, fullyConnected);
   public static Image BinaryFillhole(this Image image1, bool fullyConnected, double foregroundValue) => SimpleITK.BinaryFillhole(image1, fullyConnected, foregroundValue);
   public static Image BinaryGrindPeak(this Image image1) => SimpleITK.BinaryGrindPeak(image1);
   public static Image BinaryGrindPeak(this Image image1, bool fullyConnected) => SimpleITK.BinaryGrindPeak(image1, fullyConnected);
   public static Image BinaryGrindPeak(this Image image1, bool fullyConnected, double foregroundValue) => SimpleITK.BinaryGrindPeak(image1, fullyConnected, foregroundValue);
   public static Image BinaryGrindPeak(this Image image1, bool fullyConnected, double foregroundValue, double backgroundValue) => SimpleITK.BinaryGrindPeak(image1, fullyConnected, foregroundValue, backgroundValue);
   public static Image BinaryImageToLabelMap(this Image image1) => SimpleITK.BinaryImageToLabelMap(image1);
   public static Image BinaryImageToLabelMap(this Image image1, bool fullyConnected) => SimpleITK.BinaryImageToLabelMap(image1, fullyConnected);
   public static Image BinaryImageToLabelMap(this Image image1, bool fullyConnected, double inputForegroundValue) => SimpleITK.BinaryImageToLabelMap(image1, fullyConnected, inputForegroundValue);
   public static Image BinaryImageToLabelMap(this Image image1, bool fullyConnected, double inputForegroundValue, double outputBackgroundValue) => SimpleITK.BinaryImageToLabelMap(image1, fullyConnected, inputForegroundValue, outputBackgroundValue);
   public static Image BinaryMagnitude(this Image image1, Image image2) => SimpleITK.BinaryMagnitude(image1, image2);
   public static Image BinaryMedian(this Image image1) => SimpleITK.BinaryMedian(image1);
   public static Image BinaryMedian(this Image image1, VectorUInt32 radius) => SimpleITK.BinaryMedian(image1, radius);
   public static Image BinaryMedian(this Image image1, VectorUInt32 radius, double foregroundValue) => SimpleITK.BinaryMedian(image1, radius, foregroundValue);
   public static Image BinaryMedian(this Image image1, VectorUInt32 radius, double foregroundValue, double backgroundValue) => SimpleITK.BinaryMedian(image1, radius, foregroundValue, backgroundValue);
   public static Image BinaryMinMaxCurvatureFlow(this Image image1) => SimpleITK.BinaryMinMaxCurvatureFlow(image1);
   public static Image BinaryMinMaxCurvatureFlow(this Image image1, double timeStep) => SimpleITK.BinaryMinMaxCurvatureFlow(image1, timeStep);
   public static Image BinaryMinMaxCurvatureFlow(this Image image1, double timeStep, uint numberOfIterations) => SimpleITK.BinaryMinMaxCurvatureFlow(image1, timeStep, numberOfIterations);
   public static Image BinaryMinMaxCurvatureFlow(this Image image1, double timeStep, uint numberOfIterations, int stencilRadius) => SimpleITK.BinaryMinMaxCurvatureFlow(image1, timeStep, numberOfIterations, stencilRadius);
   public static Image BinaryMinMaxCurvatureFlow(this Image image1, double timeStep, uint numberOfIterations, int stencilRadius, double threshold) => SimpleITK.BinaryMinMaxCurvatureFlow(image1, timeStep, numberOfIterations, stencilRadius, threshold);
   public static Image BinaryMorphologicalClosing(this Image image1) => SimpleITK.BinaryMorphologicalClosing(image1);
   public static Image BinaryMorphologicalClosing(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.BinaryMorphologicalClosing(image1, kernelRadius);
   public static Image BinaryMorphologicalClosing(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.BinaryMorphologicalClosing(image1, kernelRadius, kernelType);
   public static Image BinaryMorphologicalClosing(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double foregroundValue) => SimpleITK.BinaryMorphologicalClosing(image1, kernelRadius, kernelType, foregroundValue);
   public static Image BinaryMorphologicalClosing(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double foregroundValue, bool safeBorder) => SimpleITK.BinaryMorphologicalClosing(image1, kernelRadius, kernelType, foregroundValue, safeBorder);
   public static Image BinaryMorphologicalOpening(this Image image1) => SimpleITK.BinaryMorphologicalOpening(image1);
   public static Image BinaryMorphologicalOpening(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.BinaryMorphologicalOpening(image1, kernelRadius);
   public static Image BinaryMorphologicalOpening(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.BinaryMorphologicalOpening(image1, kernelRadius, kernelType);
   public static Image BinaryMorphologicalOpening(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double backgroundValue) => SimpleITK.BinaryMorphologicalOpening(image1, kernelRadius, kernelType, backgroundValue);
   public static Image BinaryMorphologicalOpening(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double backgroundValue, double foregroundValue) => SimpleITK.BinaryMorphologicalOpening(image1, kernelRadius, kernelType, backgroundValue, foregroundValue);
   public static Image BinaryNot(this Image image1) => SimpleITK.BinaryNot(image1);
   public static Image BinaryNot(this Image image1, double foregroundValue) => SimpleITK.BinaryNot(image1, foregroundValue);
   public static Image BinaryNot(this Image image1, double foregroundValue, double backgroundValue) => SimpleITK.BinaryNot(image1, foregroundValue, backgroundValue);
   public static Image BinaryOpeningByReconstruction(this Image image1) => SimpleITK.BinaryOpeningByReconstruction(image1);
   public static Image BinaryOpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.BinaryOpeningByReconstruction(image1, kernelRadius);
   public static Image BinaryOpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.BinaryOpeningByReconstruction(image1, kernelRadius, kernelType);
   public static Image BinaryOpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double foregroundValue) => SimpleITK.BinaryOpeningByReconstruction(image1, kernelRadius, kernelType, foregroundValue);
   public static Image BinaryOpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double foregroundValue, double backgroundValue) => SimpleITK.BinaryOpeningByReconstruction(image1, kernelRadius, kernelType, foregroundValue, backgroundValue);
   public static Image BinaryOpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double foregroundValue, double backgroundValue, bool fullyConnected) => SimpleITK.BinaryOpeningByReconstruction(image1, kernelRadius, kernelType, foregroundValue, backgroundValue, fullyConnected);
   public static Image BinaryProjection(this Image image1) => SimpleITK.BinaryProjection(image1);
   public static Image BinaryProjection(this Image image1, uint projectionDimension) => SimpleITK.BinaryProjection(image1, projectionDimension);
   public static Image BinaryProjection(this Image image1, uint projectionDimension, double foregroundValue) => SimpleITK.BinaryProjection(image1, projectionDimension, foregroundValue);
   public static Image BinaryProjection(this Image image1, uint projectionDimension, double foregroundValue, double backgroundValue) => SimpleITK.BinaryProjection(image1, projectionDimension, foregroundValue, backgroundValue);
   public static Image BinaryPruning(this Image image1) => SimpleITK.BinaryPruning(image1);
   public static Image BinaryPruning(this Image image1, uint iteration) => SimpleITK.BinaryPruning(image1, iteration);
   public static Image BinaryReconstructionByDilation(this Image markerImage, Image maskImage) => SimpleITK.BinaryReconstructionByDilation(markerImage, maskImage);
   public static Image BinaryReconstructionByDilation(this Image markerImage, Image maskImage, double backgroundValue) => SimpleITK.BinaryReconstructionByDilation(markerImage, maskImage, backgroundValue);
   public static Image BinaryReconstructionByDilation(this Image markerImage, Image maskImage, double backgroundValue, double foregroundValue) => SimpleITK.BinaryReconstructionByDilation(markerImage, maskImage, backgroundValue, foregroundValue);
   public static Image BinaryReconstructionByDilation(this Image markerImage, Image maskImage, double backgroundValue, double foregroundValue, bool fullyConnected) => SimpleITK.BinaryReconstructionByDilation(markerImage, maskImage, backgroundValue, foregroundValue, fullyConnected);
   public static Image BinaryReconstructionByErosion(this Image markerImage, Image maskImage) => SimpleITK.BinaryReconstructionByErosion(markerImage, maskImage);
   public static Image BinaryReconstructionByErosion(this Image markerImage, Image maskImage, double backgroundValue) => SimpleITK.BinaryReconstructionByErosion(markerImage, maskImage, backgroundValue);
   public static Image BinaryReconstructionByErosion(this Image markerImage, Image maskImage, double backgroundValue, double foregroundValue) => SimpleITK.BinaryReconstructionByErosion(markerImage, maskImage, backgroundValue, foregroundValue);
   public static Image BinaryReconstructionByErosion(this Image markerImage, Image maskImage, double backgroundValue, double foregroundValue, bool fullyConnected) => SimpleITK.BinaryReconstructionByErosion(markerImage, maskImage, backgroundValue, foregroundValue, fullyConnected);
   public static Image BinaryThinning(this Image image1) => SimpleITK.BinaryThinning(image1);
   public static Image BinaryThreshold(this Image image1) => SimpleITK.BinaryThreshold(image1);
   public static Image BinaryThreshold(this Image image1, double lowerThreshold) => SimpleITK.BinaryThreshold(image1, lowerThreshold);
   public static Image BinaryThreshold(this Image image1, double lowerThreshold, double upperThreshold) => SimpleITK.BinaryThreshold(image1, lowerThreshold, upperThreshold);
   public static Image BinaryThreshold(this Image image1, double lowerThreshold, double upperThreshold, byte insideValue) => SimpleITK.BinaryThreshold(image1, lowerThreshold, upperThreshold, insideValue);
   public static Image BinaryThreshold(this Image image1, double lowerThreshold, double upperThreshold, byte insideValue, byte outsideValue) => SimpleITK.BinaryThreshold(image1, lowerThreshold, upperThreshold, insideValue, outsideValue);
   public static Image BinaryThresholdProjection(this Image image1) => SimpleITK.BinaryThresholdProjection(image1);
   public static Image BinaryThresholdProjection(this Image image1, uint projectionDimension) => SimpleITK.BinaryThresholdProjection(image1, projectionDimension);
   public static Image BinaryThresholdProjection(this Image image1, uint projectionDimension, double thresholdValue) => SimpleITK.BinaryThresholdProjection(image1, projectionDimension, thresholdValue);
   public static Image BinaryThresholdProjection(this Image image1, uint projectionDimension, double thresholdValue, byte foregroundValue) => SimpleITK.BinaryThresholdProjection(image1, projectionDimension, thresholdValue, foregroundValue);
   public static Image BinaryThresholdProjection(this Image image1, uint projectionDimension, double thresholdValue, byte foregroundValue, byte backgroundValue) => SimpleITK.BinaryThresholdProjection(image1, projectionDimension, thresholdValue, foregroundValue, backgroundValue);
   public static Image BinomialBlur(this Image image1) => SimpleITK.BinomialBlur(image1);
   public static Image BinomialBlur(this Image image1, uint repetitions) => SimpleITK.BinomialBlur(image1, repetitions);
   public static Image BinShrink(this Image image1) => SimpleITK.BinShrink(image1);
   public static Image BinShrink(this Image image1, VectorUInt32 shrinkFactors) => SimpleITK.BinShrink(image1, shrinkFactors);
   public static Image BitwiseNot(this Image image1) => SimpleITK.BitwiseNot(image1);
   public static Image BlackTopHat(this Image image1) => SimpleITK.BlackTopHat(image1);
   public static Image BlackTopHat(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.BlackTopHat(image1, kernelRadius);
   public static Image BlackTopHat(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.BlackTopHat(image1, kernelRadius, kernelType);
   public static Image BlackTopHat(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, bool safeBorder) => SimpleITK.BlackTopHat(image1, kernelRadius, kernelType, safeBorder);
   public static Image BoundedReciprocal(this Image image1) => SimpleITK.BoundedReciprocal(image1);
   public static Image BoxMean(this Image image1) => SimpleITK.BoxMean(image1);
   public static Image BoxMean(this Image image1, VectorUInt32 radius) => SimpleITK.BoxMean(image1, radius);
   public static Image BoxSigma(this Image image1) => SimpleITK.BoxSigma(image1);
   public static Image BoxSigma(this Image image1, VectorUInt32 radius) => SimpleITK.BoxSigma(image1, radius);
   public static Image BSplineDecomposition(this Image image1) => SimpleITK.BSplineDecomposition(image1);
   public static Image BSplineDecomposition(this Image image1, uint splineOrder) => SimpleITK.BSplineDecomposition(image1, splineOrder);
   public static Image CannyEdgeDetection(this Image image1) => SimpleITK.CannyEdgeDetection(image1);
   public static Image CannyEdgeDetection(this Image image1, double lowerThreshold) => SimpleITK.CannyEdgeDetection(image1, lowerThreshold);
   public static Image CannyEdgeDetection(this Image image1, double lowerThreshold, double upperThreshold) => SimpleITK.CannyEdgeDetection(image1, lowerThreshold, upperThreshold);
   public static Image CannyEdgeDetection(this Image image1, double lowerThreshold, double upperThreshold, VectorDouble variance) => SimpleITK.CannyEdgeDetection(image1, lowerThreshold, upperThreshold, variance);
   public static Image CannyEdgeDetection(this Image image1, double lowerThreshold, double upperThreshold, VectorDouble variance, VectorDouble maximumError) => SimpleITK.CannyEdgeDetection(image1, lowerThreshold, upperThreshold, variance, maximumError);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold, double variance) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold, variance);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold, double variance, double maximumRMSError) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold, variance, maximumRMSError);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold, double variance, double maximumRMSError, double propagationScaling) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold, variance, maximumRMSError, propagationScaling);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold, double variance, double maximumRMSError, double propagationScaling, double curvatureScaling) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold, variance, maximumRMSError, propagationScaling, curvatureScaling);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold, double variance, double maximumRMSError, double propagationScaling, double curvatureScaling, double advectionScaling) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold, variance, maximumRMSError, propagationScaling, curvatureScaling, advectionScaling);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold, double variance, double maximumRMSError, double propagationScaling, double curvatureScaling, double advectionScaling, uint numberOfIterations) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold, variance, maximumRMSError, propagationScaling, curvatureScaling, advectionScaling, numberOfIterations);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold, double variance, double maximumRMSError, double propagationScaling, double curvatureScaling, double advectionScaling, uint numberOfIterations, bool reverseExpansionDirection, double isoSurfaceValue) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold, variance, maximumRMSError, propagationScaling, curvatureScaling, advectionScaling, numberOfIterations, reverseExpansionDirection, isoSurfaceValue);
   public static Image CannySegmentationLevelSet(this Image initialImage, Image featureImage, double threshold, double variance, double maximumRMSError, double propagationScaling, double curvatureScaling, double advectionScaling, uint numberOfIterations, bool reverseExpansionDirection) => SimpleITK.CannySegmentationLevelSet(initialImage, featureImage, threshold, variance, maximumRMSError, propagationScaling, curvatureScaling, advectionScaling, numberOfIterations, reverseExpansionDirection);
   public static Image Cast(this Image image, PixelIDValueEnum pixelID) => SimpleITK.Cast(image, pixelID);
   public static Image ChangeLabel(this Image image1) => SimpleITK.ChangeLabel(image1);
   public static Image ChangeLabel(this Image image1, DoubleDoubleMap changeMap) => SimpleITK.ChangeLabel(image1, changeMap);
   public static Image ChangeLabelLabelMap(this Image image1) => SimpleITK.ChangeLabelLabelMap(image1);
   public static Image ChangeLabelLabelMap(this Image image1, DoubleDoubleMap changeMap) => SimpleITK.ChangeLabelLabelMap(image1, changeMap);
   public static Image CheckerBoard(this Image image1, Image image2) => SimpleITK.CheckerBoard(image1, image2);
   public static Image CheckerBoard(this Image image1, Image image2, VectorUInt32 checkerPattern) => SimpleITK.CheckerBoard(image1, image2, checkerPattern);
   public static Image Clamp(this Image image1) => SimpleITK.Clamp(image1);
   public static Image Clamp(this Image image1, PixelIDValueEnum outputPixelType) => SimpleITK.Clamp(image1, outputPixelType);
   public static Image Clamp(this Image image1, PixelIDValueEnum outputPixelType, double lowerBound) => SimpleITK.Clamp(image1, outputPixelType, lowerBound);
   public static Image Clamp(this Image image1, PixelIDValueEnum outputPixelType, double lowerBound, double upperBound) => SimpleITK.Clamp(image1, outputPixelType, lowerBound, upperBound);
   public static Image ClosingByReconstruction(this Image image1) => SimpleITK.ClosingByReconstruction(image1);
   public static Image ClosingByReconstruction(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.ClosingByReconstruction(image1, kernelRadius);
   public static Image ClosingByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.ClosingByReconstruction(image1, kernelRadius, kernelType);
   public static Image ClosingByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, bool fullyConnected) => SimpleITK.ClosingByReconstruction(image1, kernelRadius, kernelType, fullyConnected);
   public static Image ClosingByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, bool fullyConnected, bool preserveIntensities) => SimpleITK.ClosingByReconstruction(image1, kernelRadius, kernelType, fullyConnected, preserveIntensities);
   public static Image CollidingFronts(this Image image1) => SimpleITK.CollidingFronts(image1);
   public static Image CollidingFronts(this Image image1, VectorUIntList seedPoints1) => SimpleITK.CollidingFronts(image1, seedPoints1);
   public static Image CollidingFronts(this Image image1, VectorUIntList seedPoints1, VectorUIntList seedPoints2) => SimpleITK.CollidingFronts(image1, seedPoints1, seedPoints2);
   public static Image CollidingFronts(this Image image1, VectorUIntList seedPoints1, VectorUIntList seedPoints2, bool applyConnectivity) => SimpleITK.CollidingFronts(image1, seedPoints1, seedPoints2, applyConnectivity);
   public static Image CollidingFronts(this Image image1, VectorUIntList seedPoints1, VectorUIntList seedPoints2, bool applyConnectivity, double negativeEpsilon) => SimpleITK.CollidingFronts(image1, seedPoints1, seedPoints2, applyConnectivity, negativeEpsilon);
   public static Image CollidingFronts(this Image image1, VectorUIntList seedPoints1, VectorUIntList seedPoints2, bool applyConnectivity, double negativeEpsilon, bool stopOnTargets) => SimpleITK.CollidingFronts(image1, seedPoints1, seedPoints2, applyConnectivity, negativeEpsilon, stopOnTargets);
   public static Image ComplexToImaginary(this Image image1) => SimpleITK.ComplexToImaginary(image1);
   public static Image ComplexToModulus(this Image image1) => SimpleITK.ComplexToModulus(image1);
   public static Image ComplexToPhase(this Image image1) => SimpleITK.ComplexToPhase(image1);
   public static Image ComplexToReal(this Image image1) => SimpleITK.ComplexToReal(image1);
   public static Image Compose(this Image image1) => SimpleITK.Compose(image1);
   public static Image Compose(this Image image1, Image image2) => SimpleITK.Compose(image1, image2);
   public static Image Compose(this Image image1, Image image2, Image image3) => SimpleITK.Compose(image1, image2, image3);
   public static Image Compose(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.Compose(image1, image2, image3, image4);
   public static Image Compose(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.Compose(image1, image2, image3, image4, image5);
   public static Image Compose(this VectorOfImage images) => SimpleITK.Compose(images);
   public static Image ConfidenceConnected(this Image image1) => SimpleITK.ConfidenceConnected(image1);
   public static Image ConfidenceConnected(this Image image1, VectorUIntList seedList) => SimpleITK.ConfidenceConnected(image1, seedList);
   public static Image ConfidenceConnected(this Image image1, VectorUIntList seedList, uint numberOfIterations) => SimpleITK.ConfidenceConnected(image1, seedList, numberOfIterations);
   public static Image ConfidenceConnected(this Image image1, VectorUIntList seedList, uint numberOfIterations, double multiplier) => SimpleITK.ConfidenceConnected(image1, seedList, numberOfIterations, multiplier);
   public static Image ConfidenceConnected(this Image image1, VectorUIntList seedList, uint numberOfIterations, double multiplier, uint initialNeighborhoodRadius) => SimpleITK.ConfidenceConnected(image1, seedList, numberOfIterations, multiplier, initialNeighborhoodRadius);
   public static Image ConfidenceConnected(this Image image1, VectorUIntList seedList, uint numberOfIterations, double multiplier, uint initialNeighborhoodRadius, byte replaceValue) => SimpleITK.ConfidenceConnected(image1, seedList, numberOfIterations, multiplier, initialNeighborhoodRadius, replaceValue);
   public static Image ConnectedComponent(this Image image) => SimpleITK.ConnectedComponent(image);
   public static Image ConnectedComponent(this Image image, bool fullyConnected) => SimpleITK.ConnectedComponent(image, fullyConnected);
   public static Image ConnectedComponent(this Image image, Image maskImage) => SimpleITK.ConnectedComponent(image, maskImage);
   public static Image ConnectedComponent(this Image image, Image maskImage, bool fullyConnected) => SimpleITK.ConnectedComponent(image, maskImage, fullyConnected);
   public static Image ConnectedThreshold(this Image image1) => SimpleITK.ConnectedThreshold(image1);
   public static Image ConnectedThreshold(this Image image1, VectorUIntList seedList) => SimpleITK.ConnectedThreshold(image1, seedList);
   public static Image ConnectedThreshold(this Image image1, VectorUIntList seedList, double lower) => SimpleITK.ConnectedThreshold(image1, seedList, lower);
   public static Image ConnectedThreshold(this Image image1, VectorUIntList seedList, double lower, double upper) => SimpleITK.ConnectedThreshold(image1, seedList, lower, upper);
   public static Image ConnectedThreshold(this Image image1, VectorUIntList seedList, double lower, double upper, byte replaceValue) => SimpleITK.ConnectedThreshold(image1, seedList, lower, upper, replaceValue);
   public static Image ConnectedThreshold(this Image image1, VectorUIntList seedList, double lower, double upper, byte replaceValue, ConnectedThresholdImageFilter.ConnectivityType connectivity) => SimpleITK.ConnectedThreshold(image1, seedList, lower, upper, replaceValue, connectivity);
   public static Image ConstantPad(this Image image1) => SimpleITK.ConstantPad(image1);
   public static Image ConstantPad(this Image image1, VectorUInt32 padLowerBound) => SimpleITK.ConstantPad(image1, padLowerBound);
   public static Image ConstantPad(this Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) => SimpleITK.ConstantPad(image1, padLowerBound, padUpperBound);
   public static Image ConstantPad(this Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound, double constant) => SimpleITK.ConstantPad(image1, padLowerBound, padUpperBound, constant);
   public static Image Convolution(this Image image, Image kernelImage) => SimpleITK.Convolution(image, kernelImage);
   public static Image Convolution(this Image image, Image kernelImage, bool normalize) => SimpleITK.Convolution(image, kernelImage, normalize);
   public static Image Convolution(this Image image, Image kernelImage, bool normalize, ConvolutionImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.Convolution(image, kernelImage, normalize, boundaryCondition);
   public static Image Convolution(this Image image, Image kernelImage, bool normalize, ConvolutionImageFilter.BoundaryConditionType boundaryCondition, ConvolutionImageFilter.OutputRegionModeType outputRegionMode) => SimpleITK.Convolution(image, kernelImage, normalize, boundaryCondition, outputRegionMode);
   public static Image Cos(this Image image1) => SimpleITK.Cos(image1);
   public static Image Crop(this Image image1) => SimpleITK.Crop(image1);
   public static Image Crop(this Image image1, VectorUInt32 lowerBoundaryCropSize) => SimpleITK.Crop(image1, lowerBoundaryCropSize);
   public static Image Crop(this Image image1, VectorUInt32 lowerBoundaryCropSize, VectorUInt32 upperBoundaryCropSize) => SimpleITK.Crop(image1, lowerBoundaryCropSize, upperBoundaryCropSize);
   public static Image CurvatureAnisotropicDiffusion(this Image image1) => SimpleITK.CurvatureAnisotropicDiffusion(image1);
   public static Image CurvatureAnisotropicDiffusion(this Image image1, double timeStep) => SimpleITK.CurvatureAnisotropicDiffusion(image1, timeStep);
   public static Image CurvatureAnisotropicDiffusion(this Image image1, double timeStep, double conductanceParameter) => SimpleITK.CurvatureAnisotropicDiffusion(image1, timeStep, conductanceParameter);
   public static Image CurvatureAnisotropicDiffusion(this Image image1, double timeStep, double conductanceParameter, uint conductanceScalingUpdateInterval) => SimpleITK.CurvatureAnisotropicDiffusion(image1, timeStep, conductanceParameter, conductanceScalingUpdateInterval);
   public static Image CurvatureAnisotropicDiffusion(this Image image1, double timeStep, double conductanceParameter, uint conductanceScalingUpdateInterval, uint numberOfIterations) => SimpleITK.CurvatureAnisotropicDiffusion(image1, timeStep, conductanceParameter, conductanceScalingUpdateInterval, numberOfIterations);
   public static Image CurvatureFlow(this Image image1) => SimpleITK.CurvatureFlow(image1);
   public static Image CurvatureFlow(this Image image1, double timeStep) => SimpleITK.CurvatureFlow(image1, timeStep);
   public static Image CurvatureFlow(this Image image1, double timeStep, uint numberOfIterations) => SimpleITK.CurvatureFlow(image1, timeStep, numberOfIterations);
   public static Image CyclicShift(this Image image1) => SimpleITK.CyclicShift(image1);
   public static Image CyclicShift(this Image image1, VectorInt32 shift) => SimpleITK.CyclicShift(image1, shift);
   public static Image DanielssonDistanceMap(this Image image1) => SimpleITK.DanielssonDistanceMap(image1);
   public static Image DanielssonDistanceMap(this Image image1, bool inputIsBinary) => SimpleITK.DanielssonDistanceMap(image1, inputIsBinary);
   public static Image DanielssonDistanceMap(this Image image1, bool inputIsBinary, bool squaredDistance) => SimpleITK.DanielssonDistanceMap(image1, inputIsBinary, squaredDistance);
   public static Image DanielssonDistanceMap(this Image image1, bool inputIsBinary, bool squaredDistance, bool useImageSpacing) => SimpleITK.DanielssonDistanceMap(image1, inputIsBinary, squaredDistance, useImageSpacing);
   public static Image Derivative(this Image image1) => SimpleITK.Derivative(image1);
   public static Image Derivative(this Image image1, uint direction) => SimpleITK.Derivative(image1, direction);
   public static Image Derivative(this Image image1, uint direction, uint order) => SimpleITK.Derivative(image1, direction, order);
   public static Image Derivative(this Image image1, uint direction, uint order, bool useImageSpacing) => SimpleITK.Derivative(image1, direction, order, useImageSpacing);
   public static Image DICOMOrient(this Image image1) => SimpleITK.DICOMOrient(image1);
   public static Image DICOMOrient(this Image image1, string desiredCoordinateOrientation) => SimpleITK.DICOMOrient(image1, desiredCoordinateOrientation);
   public static Image DilateObjectMorphology(this Image image1) => SimpleITK.DilateObjectMorphology(image1);
   public static Image DilateObjectMorphology(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.DilateObjectMorphology(image1, kernelRadius);
   public static Image DilateObjectMorphology(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.DilateObjectMorphology(image1, kernelRadius, kernelType);
   public static Image DilateObjectMorphology(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double objectValue) => SimpleITK.DilateObjectMorphology(image1, kernelRadius, kernelType, objectValue);
   public static Image DiscreteGaussian(this Image image1) => SimpleITK.DiscreteGaussian(image1);
   public static Image DiscreteGaussian(this Image image1, double variance) => SimpleITK.DiscreteGaussian(image1, variance);
   public static Image DiscreteGaussian(this Image image1, double variance, uint maximumKernelWidth) => SimpleITK.DiscreteGaussian(image1, variance, maximumKernelWidth);
   public static Image DiscreteGaussian(this Image image1, double variance, uint maximumKernelWidth, double maximumError) => SimpleITK.DiscreteGaussian(image1, variance, maximumKernelWidth, maximumError);
   public static Image DiscreteGaussian(this Image image1, double variance, uint maximumKernelWidth, double maximumError, bool useImageSpacing) => SimpleITK.DiscreteGaussian(image1, variance, maximumKernelWidth, maximumError, useImageSpacing);
   public static Image DiscreteGaussian(this Image image1, VectorDouble variance) => SimpleITK.DiscreteGaussian(image1, variance);
   public static Image DiscreteGaussian(this Image image1, VectorDouble variance, uint maximumKernelWidth) => SimpleITK.DiscreteGaussian(image1, variance, maximumKernelWidth);
   public static Image DiscreteGaussian(this Image image1, VectorDouble variance, uint maximumKernelWidth, VectorDouble maximumError) => SimpleITK.DiscreteGaussian(image1, variance, maximumKernelWidth, maximumError);
   public static Image DiscreteGaussian(this Image image1, VectorDouble variance, uint maximumKernelWidth, VectorDouble maximumError, bool useImageSpacing) => SimpleITK.DiscreteGaussian(image1, variance, maximumKernelWidth, maximumError, useImageSpacing);
   public static Image DiscreteGaussianDerivative(this Image image1) => SimpleITK.DiscreteGaussianDerivative(image1);
   public static Image DiscreteGaussianDerivative(this Image image1, VectorDouble variance) => SimpleITK.DiscreteGaussianDerivative(image1, variance);
   public static Image DiscreteGaussianDerivative(this Image image1, VectorDouble variance, VectorUInt32 order) => SimpleITK.DiscreteGaussianDerivative(image1, variance, order);
   public static Image DiscreteGaussianDerivative(this Image image1, VectorDouble variance, VectorUInt32 order, uint maximumKernelWidth) => SimpleITK.DiscreteGaussianDerivative(image1, variance, order, maximumKernelWidth);
   public static Image DiscreteGaussianDerivative(this Image image1, VectorDouble variance, VectorUInt32 order, uint maximumKernelWidth, double maximumError) => SimpleITK.DiscreteGaussianDerivative(image1, variance, order, maximumKernelWidth, maximumError);
   public static Image DiscreteGaussianDerivative(this Image image1, VectorDouble variance, VectorUInt32 order, uint maximumKernelWidth, double maximumError, bool useImageSpacing) => SimpleITK.DiscreteGaussianDerivative(image1, variance, order, maximumKernelWidth, maximumError, useImageSpacing);
   public static Image DiscreteGaussianDerivative(this Image image1, VectorDouble variance, VectorUInt32 order, uint maximumKernelWidth, double maximumError, bool useImageSpacing, bool normalizeAcrossScale) => SimpleITK.DiscreteGaussianDerivative(image1, variance, order, maximumKernelWidth, maximumError, useImageSpacing, normalizeAcrossScale);
   public static Image DisplacementFieldJacobianDeterminant(this Image image1) => SimpleITK.DisplacementFieldJacobianDeterminant(image1);
   public static Image DisplacementFieldJacobianDeterminant(this Image image1, bool useImageSpacing) => SimpleITK.DisplacementFieldJacobianDeterminant(image1, useImageSpacing);
   public static Image DisplacementFieldJacobianDeterminant(this Image image1, bool useImageSpacing, VectorDouble derivativeWeights) => SimpleITK.DisplacementFieldJacobianDeterminant(image1, useImageSpacing, derivativeWeights);
   public static Image Divide(this double constant, Image image2) => SimpleITK.Divide(constant, image2);
   public static Image Divide(this Image image1, double constant) => SimpleITK.Divide(image1, constant);
   public static Image Divide(this Image image1, Image image2) => SimpleITK.Divide(image1, image2);
   public static Image DivideFloor(this double constant, Image image2) => SimpleITK.DivideFloor(constant, image2);
   public static Image DivideFloor(this Image image1, double constant) => SimpleITK.DivideFloor(image1, constant);
   public static Image DivideFloor(this Image image1, Image image2) => SimpleITK.DivideFloor(image1, image2);
   public static Image DivideReal(this double constant, Image image2) => SimpleITK.DivideReal(constant, image2);
   public static Image DivideReal(this Image image1, double constant) => SimpleITK.DivideReal(image1, constant);
   public static Image DivideReal(this Image image1, Image image2) => SimpleITK.DivideReal(image1, image2);
   public static Image DoubleThreshold(this Image image1) => SimpleITK.DoubleThreshold(image1);
   public static Image DoubleThreshold(this Image image1, double threshold1) => SimpleITK.DoubleThreshold(image1, threshold1);
   public static Image DoubleThreshold(this Image image1, double threshold1, double threshold2) => SimpleITK.DoubleThreshold(image1, threshold1, threshold2);
   public static Image DoubleThreshold(this Image image1, double threshold1, double threshold2, double threshold3) => SimpleITK.DoubleThreshold(image1, threshold1, threshold2, threshold3);
   public static Image DoubleThreshold(this Image image1, double threshold1, double threshold2, double threshold3, double threshold4) => SimpleITK.DoubleThreshold(image1, threshold1, threshold2, threshold3, threshold4);
   public static Image DoubleThreshold(this Image image1, double threshold1, double threshold2, double threshold3, double threshold4, byte insideValue) => SimpleITK.DoubleThreshold(image1, threshold1, threshold2, threshold3, threshold4, insideValue);
   public static Image DoubleThreshold(this Image image1, double threshold1, double threshold2, double threshold3, double threshold4, byte insideValue, byte outsideValue) => SimpleITK.DoubleThreshold(image1, threshold1, threshold2, threshold3, threshold4, insideValue, outsideValue);
   public static Image DoubleThreshold(this Image image1, double threshold1, double threshold2, double threshold3, double threshold4, byte insideValue, byte outsideValue, bool fullyConnected) => SimpleITK.DoubleThreshold(image1, threshold1, threshold2, threshold3, threshold4, insideValue, outsideValue, fullyConnected);
   public static Image EdgePotential(this Image image1) => SimpleITK.EdgePotential(image1);
   public static Image Equal(this double constant, Image image2) => SimpleITK.Equal(constant, image2);
   public static Image Equal(this double constant, Image image2, byte backgroundValue) => SimpleITK.Equal(constant, image2, backgroundValue);
   public static Image Equal(this double constant, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.Equal(constant, image2, backgroundValue, foregroundValue);
   public static Image Equal(this Image image1, double constant) => SimpleITK.Equal(image1, constant);
   public static Image Equal(this Image image1, double constant, byte backgroundValue) => SimpleITK.Equal(image1, constant, backgroundValue);
   public static Image Equal(this Image image1, double constant, byte backgroundValue, byte foregroundValue) => SimpleITK.Equal(image1, constant, backgroundValue, foregroundValue);
   public static Image Equal(this Image image1, Image image2) => SimpleITK.Equal(image1, image2);
   public static Image Equal(this Image image1, Image image2, byte backgroundValue) => SimpleITK.Equal(image1, image2, backgroundValue);
   public static Image Equal(this Image image1, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.Equal(image1, image2, backgroundValue, foregroundValue);
   public static Image ErodeObjectMorphology(this Image image1) => SimpleITK.ErodeObjectMorphology(image1);
   public static Image ErodeObjectMorphology(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.ErodeObjectMorphology(image1, kernelRadius);
   public static Image ErodeObjectMorphology(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.ErodeObjectMorphology(image1, kernelRadius, kernelType);
   public static Image ErodeObjectMorphology(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double objectValue) => SimpleITK.ErodeObjectMorphology(image1, kernelRadius, kernelType, objectValue);
   public static Image ErodeObjectMorphology(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, double objectValue, double backgroundValue) => SimpleITK.ErodeObjectMorphology(image1, kernelRadius, kernelType, objectValue, backgroundValue);
   public static Image Exp(this Image image1) => SimpleITK.Exp(image1);
   public static Image Expand(this Image image1) => SimpleITK.Expand(image1);
   public static Image Expand(this Image image1, VectorUInt32 expandFactors) => SimpleITK.Expand(image1, expandFactors);
   public static Image Expand(this Image image1, VectorUInt32 expandFactors, InterpolatorEnum interpolator) => SimpleITK.Expand(image1, expandFactors, interpolator);
   public static Image ExpNegative(this Image image1) => SimpleITK.ExpNegative(image1);
   public static Image Extract(this Image image1) => SimpleITK.Extract(image1);
   public static Image Extract(this Image image1, VectorUInt32 size) => SimpleITK.Extract(image1, size);
   public static Image Extract(this Image image1, VectorUInt32 size, VectorInt32 index) => SimpleITK.Extract(image1, size, index);
   public static Image Extract(this Image image1, VectorUInt32 size, VectorInt32 index, ExtractImageFilter.DirectionCollapseToStrategyType directionCollapseToStrategy) => SimpleITK.Extract(image1, size, index, directionCollapseToStrategy);
   public static Image FastApproximateRank(this Image image1) => SimpleITK.FastApproximateRank(image1);
   public static Image FastApproximateRank(this Image image1, double rank) => SimpleITK.FastApproximateRank(image1, rank);
   public static Image FastApproximateRank(this Image image1, double rank, VectorUInt32 radius) => SimpleITK.FastApproximateRank(image1, rank, radius);
   public static Image FastMarching(this Image image1) => SimpleITK.FastMarching(image1);
   public static Image FastMarching(this Image image1, VectorUIntList trialPoints) => SimpleITK.FastMarching(image1, trialPoints);
   public static Image FastMarching(this Image image1, VectorUIntList trialPoints, double normalizationFactor) => SimpleITK.FastMarching(image1, trialPoints, normalizationFactor);
   public static Image FastMarching(this Image image1, VectorUIntList trialPoints, double normalizationFactor, double stoppingValue) => SimpleITK.FastMarching(image1, trialPoints, normalizationFactor, stoppingValue);
   public static Image FastMarching(this Image image1, VectorUIntList trialPoints, double normalizationFactor, double stoppingValue, VectorDouble initialTrialValues) => SimpleITK.FastMarching(image1, trialPoints, normalizationFactor, stoppingValue, initialTrialValues);
   public static Image FastMarchingBase(this Image image1) => SimpleITK.FastMarchingBase(image1);
   public static Image FastMarchingBase(this Image image1, VectorUIntList trialPoints) => SimpleITK.FastMarchingBase(image1, trialPoints);
   public static Image FastMarchingBase(this Image image1, VectorUIntList trialPoints, double normalizationFactor) => SimpleITK.FastMarchingBase(image1, trialPoints, normalizationFactor);
   public static Image FastMarchingBase(this Image image1, VectorUIntList trialPoints, double normalizationFactor, double stoppingValue) => SimpleITK.FastMarchingBase(image1, trialPoints, normalizationFactor, stoppingValue);
   public static Image FastMarchingBase(this Image image1, VectorUIntList trialPoints, double normalizationFactor, double stoppingValue, FastMarchingBaseImageFilter.TopologyCheckType topologyCheck) => SimpleITK.FastMarchingBase(image1, trialPoints, normalizationFactor, stoppingValue, topologyCheck);
   public static Image FastMarchingBase(this Image image1, VectorUIntList trialPoints, double normalizationFactor, double stoppingValue, FastMarchingBaseImageFilter.TopologyCheckType topologyCheck, VectorDouble initialTrialValues) => SimpleITK.FastMarchingBase(image1, trialPoints, normalizationFactor, stoppingValue, topologyCheck, initialTrialValues);
   public static Image FastMarchingUpwindGradient(this Image image1) => SimpleITK.FastMarchingUpwindGradient(image1);
   public static Image FastMarchingUpwindGradient(this Image image1, VectorUIntList trialPoints) => SimpleITK.FastMarchingUpwindGradient(image1, trialPoints);
   public static Image FastMarchingUpwindGradient(this Image image1, VectorUIntList trialPoints, uint numberOfTargets) => SimpleITK.FastMarchingUpwindGradient(image1, trialPoints, numberOfTargets);
   public static Image FastMarchingUpwindGradient(this Image image1, VectorUIntList trialPoints, uint numberOfTargets, VectorUIntList targetPoints) => SimpleITK.FastMarchingUpwindGradient(image1, trialPoints, numberOfTargets, targetPoints);
   public static Image FastMarchingUpwindGradient(this Image image1, VectorUIntList trialPoints, uint numberOfTargets, VectorUIntList targetPoints, double targetOffset) => SimpleITK.FastMarchingUpwindGradient(image1, trialPoints, numberOfTargets, targetPoints, targetOffset);
   public static Image FastMarchingUpwindGradient(this Image image1, VectorUIntList trialPoints, uint numberOfTargets, VectorUIntList targetPoints, double targetOffset, double normalizationFactor) => SimpleITK.FastMarchingUpwindGradient(image1, trialPoints, numberOfTargets, targetPoints, targetOffset, normalizationFactor);
   public static Image FastMarchingUpwindGradient(this Image image1, VectorUIntList trialPoints, uint numberOfTargets, VectorUIntList targetPoints, double targetOffset, double normalizationFactor, VectorDouble initialTrialValues) => SimpleITK.FastMarchingUpwindGradient(image1, trialPoints, numberOfTargets, targetPoints, targetOffset, normalizationFactor, initialTrialValues);
   public static Image FFTConvolution(this Image image, Image kernelImage) => SimpleITK.FFTConvolution(image, kernelImage);
   public static Image FFTConvolution(this Image image, Image kernelImage, bool normalize) => SimpleITK.FFTConvolution(image, kernelImage, normalize);
   public static Image FFTConvolution(this Image image, Image kernelImage, bool normalize, FFTConvolutionImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.FFTConvolution(image, kernelImage, normalize, boundaryCondition);
   public static Image FFTConvolution(this Image image, Image kernelImage, bool normalize, FFTConvolutionImageFilter.BoundaryConditionType boundaryCondition, FFTConvolutionImageFilter.OutputRegionModeType outputRegionMode) => SimpleITK.FFTConvolution(image, kernelImage, normalize, boundaryCondition, outputRegionMode);
   public static Image FFTNormalizedCorrelation(this Image fixedImage, Image movingImage) => SimpleITK.FFTNormalizedCorrelation(fixedImage, movingImage);
   public static Image FFTNormalizedCorrelation(this Image fixedImage, Image movingImage, ulong requiredNumberOfOverlappingPixels) => SimpleITK.FFTNormalizedCorrelation(fixedImage, movingImage, requiredNumberOfOverlappingPixels);
   public static Image FFTNormalizedCorrelation(this Image fixedImage, Image movingImage, ulong requiredNumberOfOverlappingPixels, double requiredFractionOfOverlappingPixels) => SimpleITK.FFTNormalizedCorrelation(fixedImage, movingImage, requiredNumberOfOverlappingPixels, requiredFractionOfOverlappingPixels);
   public static Image FFTPad(this Image image1) => SimpleITK.FFTPad(image1);
   public static Image FFTPad(this Image image1, FFTPadImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.FFTPad(image1, boundaryCondition);
   public static Image FFTPad(this Image image1, FFTPadImageFilter.BoundaryConditionType boundaryCondition, int sizeGreatestPrimeFactor) => SimpleITK.FFTPad(image1, boundaryCondition, sizeGreatestPrimeFactor);
   public static Image FFTShift(this Image image1) => SimpleITK.FFTShift(image1);
   public static Image FFTShift(this Image image1, bool inverse) => SimpleITK.FFTShift(image1, inverse);
   public static Image Flip(this Image image1) => SimpleITK.Flip(image1);
   public static Image Flip(this Image image1, VectorBool flipAxes) => SimpleITK.Flip(image1, flipAxes);
   public static Image Flip(this Image image1, VectorBool flipAxes, bool flipAboutOrigin) => SimpleITK.Flip(image1, flipAxes, flipAboutOrigin);
   public static Image ForwardFFT(this Image image1) => SimpleITK.ForwardFFT(image1);
   public static Image GradientAnisotropicDiffusion(this Image image1) => SimpleITK.GradientAnisotropicDiffusion(image1);
   public static Image GradientAnisotropicDiffusion(this Image image1, double timeStep) => SimpleITK.GradientAnisotropicDiffusion(image1, timeStep);
   public static Image GradientAnisotropicDiffusion(this Image image1, double timeStep, double conductanceParameter) => SimpleITK.GradientAnisotropicDiffusion(image1, timeStep, conductanceParameter);
   public static Image GradientAnisotropicDiffusion(this Image image1, double timeStep, double conductanceParameter, uint conductanceScalingUpdateInterval) => SimpleITK.GradientAnisotropicDiffusion(image1, timeStep, conductanceParameter, conductanceScalingUpdateInterval);
   public static Image GradientAnisotropicDiffusion(this Image image1, double timeStep, double conductanceParameter, uint conductanceScalingUpdateInterval, uint numberOfIterations) => SimpleITK.GradientAnisotropicDiffusion(image1, timeStep, conductanceParameter, conductanceScalingUpdateInterval, numberOfIterations);
   public static Image GradientMagnitude(this Image image1) => SimpleITK.GradientMagnitude(image1);
   public static Image GradientMagnitude(this Image image1, bool useImageSpacing) => SimpleITK.GradientMagnitude(image1, useImageSpacing);
   public static Image GradientMagnitudeRecursiveGaussian(this Image image1) => SimpleITK.GradientMagnitudeRecursiveGaussian(image1);
   public static Image GradientMagnitudeRecursiveGaussian(this Image image1, double sigma) => SimpleITK.GradientMagnitudeRecursiveGaussian(image1, sigma);
   public static Image GradientMagnitudeRecursiveGaussian(this Image image1, double sigma, bool normalizeAcrossScale) => SimpleITK.GradientMagnitudeRecursiveGaussian(image1, sigma, normalizeAcrossScale);
   public static Image GradientRecursiveGaussian(this Image image1) => SimpleITK.GradientRecursiveGaussian(image1);
   public static Image GradientRecursiveGaussian(this Image image1, double sigma) => SimpleITK.GradientRecursiveGaussian(image1, sigma);
   public static Image GradientRecursiveGaussian(this Image image1, double sigma, bool normalizeAcrossScale) => SimpleITK.GradientRecursiveGaussian(image1, sigma, normalizeAcrossScale);
   public static Image GradientRecursiveGaussian(this Image image1, double sigma, bool normalizeAcrossScale, bool useImageDirection) => SimpleITK.GradientRecursiveGaussian(image1, sigma, normalizeAcrossScale, useImageDirection);
   public static Image GrayscaleConnectedClosing(this Image image1) => SimpleITK.GrayscaleConnectedClosing(image1);
   public static Image GrayscaleConnectedClosing(this Image image1, VectorUInt32 seed) => SimpleITK.GrayscaleConnectedClosing(image1, seed);
   public static Image GrayscaleConnectedClosing(this Image image1, VectorUInt32 seed, bool fullyConnected) => SimpleITK.GrayscaleConnectedClosing(image1, seed, fullyConnected);
   public static Image GrayscaleConnectedOpening(this Image image1) => SimpleITK.GrayscaleConnectedOpening(image1);
   public static Image GrayscaleConnectedOpening(this Image image1, VectorUInt32 seed) => SimpleITK.GrayscaleConnectedOpening(image1, seed);
   public static Image GrayscaleConnectedOpening(this Image image1, VectorUInt32 seed, bool fullyConnected) => SimpleITK.GrayscaleConnectedOpening(image1, seed, fullyConnected);
   public static Image GrayscaleDilate(this Image image1) => SimpleITK.GrayscaleDilate(image1);
   public static Image GrayscaleDilate(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.GrayscaleDilate(image1, kernelRadius);
   public static Image GrayscaleDilate(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.GrayscaleDilate(image1, kernelRadius, kernelType);
   public static Image GrayscaleErode(this Image image1) => SimpleITK.GrayscaleErode(image1);
   public static Image GrayscaleErode(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.GrayscaleErode(image1, kernelRadius);
   public static Image GrayscaleErode(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.GrayscaleErode(image1, kernelRadius, kernelType);
   public static Image GrayscaleFillhole(this Image image1) => SimpleITK.GrayscaleFillhole(image1);
   public static Image GrayscaleFillhole(this Image image1, bool fullyConnected) => SimpleITK.GrayscaleFillhole(image1, fullyConnected);
   public static Image GrayscaleGeodesicDilate(this Image image1, Image image2) => SimpleITK.GrayscaleGeodesicDilate(image1, image2);
   public static Image GrayscaleGeodesicDilate(this Image image1, Image image2, bool runOneIteration) => SimpleITK.GrayscaleGeodesicDilate(image1, image2, runOneIteration);
   public static Image GrayscaleGeodesicDilate(this Image image1, Image image2, bool runOneIteration, bool fullyConnected) => SimpleITK.GrayscaleGeodesicDilate(image1, image2, runOneIteration, fullyConnected);
   public static Image GrayscaleGeodesicErode(this Image image1, Image image2) => SimpleITK.GrayscaleGeodesicErode(image1, image2);
   public static Image GrayscaleGeodesicErode(this Image image1, Image image2, bool runOneIteration) => SimpleITK.GrayscaleGeodesicErode(image1, image2, runOneIteration);
   public static Image GrayscaleGeodesicErode(this Image image1, Image image2, bool runOneIteration, bool fullyConnected) => SimpleITK.GrayscaleGeodesicErode(image1, image2, runOneIteration, fullyConnected);
   public static Image GrayscaleGrindPeak(this Image image1) => SimpleITK.GrayscaleGrindPeak(image1);
   public static Image GrayscaleGrindPeak(this Image image1, bool fullyConnected) => SimpleITK.GrayscaleGrindPeak(image1, fullyConnected);
   public static Image GrayscaleMorphologicalClosing(this Image image1) => SimpleITK.GrayscaleMorphologicalClosing(image1);
   public static Image GrayscaleMorphologicalClosing(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.GrayscaleMorphologicalClosing(image1, kernelRadius);
   public static Image GrayscaleMorphologicalClosing(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.GrayscaleMorphologicalClosing(image1, kernelRadius, kernelType);
   public static Image GrayscaleMorphologicalClosing(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, bool safeBorder) => SimpleITK.GrayscaleMorphologicalClosing(image1, kernelRadius, kernelType, safeBorder);
   public static Image GrayscaleMorphologicalOpening(this Image image1) => SimpleITK.GrayscaleMorphologicalOpening(image1);
   public static Image GrayscaleMorphologicalOpening(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.GrayscaleMorphologicalOpening(image1, kernelRadius);
   public static Image GrayscaleMorphologicalOpening(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.GrayscaleMorphologicalOpening(image1, kernelRadius, kernelType);
   public static Image GrayscaleMorphologicalOpening(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, bool safeBorder) => SimpleITK.GrayscaleMorphologicalOpening(image1, kernelRadius, kernelType, safeBorder);
   public static Image Greater(this double constant, Image image2) => SimpleITK.Greater(constant, image2);
   public static Image Greater(this double constant, Image image2, byte backgroundValue) => SimpleITK.Greater(constant, image2, backgroundValue);
   public static Image Greater(this double constant, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.Greater(constant, image2, backgroundValue, foregroundValue);
   public static Image Greater(this Image image1, double constant) => SimpleITK.Greater(image1, constant);
   public static Image Greater(this Image image1, double constant, byte backgroundValue) => SimpleITK.Greater(image1, constant, backgroundValue);
   public static Image Greater(this Image image1, double constant, byte backgroundValue, byte foregroundValue) => SimpleITK.Greater(image1, constant, backgroundValue, foregroundValue);
   public static Image Greater(this Image image1, Image image2) => SimpleITK.Greater(image1, image2);
   public static Image Greater(this Image image1, Image image2, byte backgroundValue) => SimpleITK.Greater(image1, image2, backgroundValue);
   public static Image Greater(this Image image1, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.Greater(image1, image2, backgroundValue, foregroundValue);
   public static Image GreaterEqual(this double constant, Image image2) => SimpleITK.GreaterEqual(constant, image2);
   public static Image GreaterEqual(this double constant, Image image2, byte backgroundValue) => SimpleITK.GreaterEqual(constant, image2, backgroundValue);
   public static Image GreaterEqual(this double constant, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.GreaterEqual(constant, image2, backgroundValue, foregroundValue);
   public static Image GreaterEqual(this Image image1, double constant) => SimpleITK.GreaterEqual(image1, constant);
   public static Image GreaterEqual(this Image image1, double constant, byte backgroundValue) => SimpleITK.GreaterEqual(image1, constant, backgroundValue);
   public static Image GreaterEqual(this Image image1, double constant, byte backgroundValue, byte foregroundValue) => SimpleITK.GreaterEqual(image1, constant, backgroundValue, foregroundValue);
   public static Image GreaterEqual(this Image image1, Image image2) => SimpleITK.GreaterEqual(image1, image2);
   public static Image GreaterEqual(this Image image1, Image image2, byte backgroundValue) => SimpleITK.GreaterEqual(image1, image2, backgroundValue);
   public static Image GreaterEqual(this Image image1, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.GreaterEqual(image1, image2, backgroundValue, foregroundValue);
   public static Image HalfHermitianToRealInverseFFT(this Image image1) => SimpleITK.HalfHermitianToRealInverseFFT(image1);
   public static Image HalfHermitianToRealInverseFFT(this Image image1, bool actualXDimensionIsOdd) => SimpleITK.HalfHermitianToRealInverseFFT(image1, actualXDimensionIsOdd);
   public static Image HConcave(this Image image1) => SimpleITK.HConcave(image1);
   public static Image HConcave(this Image image1, double height) => SimpleITK.HConcave(image1, height);
   public static Image HConcave(this Image image1, double height, bool fullyConnected) => SimpleITK.HConcave(image1, height, fullyConnected);
   public static Image HConvex(this Image image1) => SimpleITK.HConvex(image1);
   public static Image HConvex(this Image image1, double height) => SimpleITK.HConvex(image1, height);
   public static Image HConvex(this Image image1, double height, bool fullyConnected) => SimpleITK.HConvex(image1, height, fullyConnected);
   public static Image HistogramMatching(this Image image, Image referenceImage) => SimpleITK.HistogramMatching(image, referenceImage);
   public static Image HistogramMatching(this Image image, Image referenceImage, uint numberOfHistogramLevels) => SimpleITK.HistogramMatching(image, referenceImage, numberOfHistogramLevels);
   public static Image HistogramMatching(this Image image, Image referenceImage, uint numberOfHistogramLevels, uint numberOfMatchPoints) => SimpleITK.HistogramMatching(image, referenceImage, numberOfHistogramLevels, numberOfMatchPoints);
   public static Image HistogramMatching(this Image image, Image referenceImage, uint numberOfHistogramLevels, uint numberOfMatchPoints, bool thresholdAtMeanIntensity) => SimpleITK.HistogramMatching(image, referenceImage, numberOfHistogramLevels, numberOfMatchPoints, thresholdAtMeanIntensity);
   public static Image HMaxima(this Image image1) => SimpleITK.HMaxima(image1);
   public static Image HMaxima(this Image image1, double height) => SimpleITK.HMaxima(image1, height);
   public static Image HMinima(this Image image1) => SimpleITK.HMinima(image1);
   public static Image HMinima(this Image image1, double height) => SimpleITK.HMinima(image1, height);
   public static Image HMinima(this Image image1, double height, bool fullyConnected) => SimpleITK.HMinima(image1, height, fullyConnected);
   public static Image HuangThreshold(this Image image) => SimpleITK.HuangThreshold(image);
   public static Image HuangThreshold(this Image image, byte insideValue) => SimpleITK.HuangThreshold(image, insideValue);
   public static Image HuangThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.HuangThreshold(image, insideValue, outsideValue);
   public static Image HuangThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.HuangThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image HuangThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.HuangThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image HuangThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.HuangThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image HuangThreshold(this Image image, Image maskImage) => SimpleITK.HuangThreshold(image, maskImage);
   public static Image HuangThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.HuangThreshold(image, maskImage, insideValue);
   public static Image HuangThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.HuangThreshold(image, maskImage, insideValue, outsideValue);
   public static Image HuangThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.HuangThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image HuangThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.HuangThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image HuangThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.HuangThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image ImportAsDouble(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsDouble(buffer, size);
   public static Image ImportAsDouble(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsDouble(buffer, size, spacing);
   public static Image ImportAsDouble(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsDouble(buffer, size, spacing, origin);
   public static Image ImportAsDouble(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsDouble(buffer, size, spacing, origin, direction);
   public static Image ImportAsDouble(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsDouble(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsFloat(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsFloat(buffer, size);
   public static Image ImportAsFloat(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsFloat(buffer, size, spacing);
   public static Image ImportAsFloat(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsFloat(buffer, size, spacing, origin);
   public static Image ImportAsFloat(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsFloat(buffer, size, spacing, origin, direction);
   public static Image ImportAsFloat(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsFloat(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsInt16(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsInt16(buffer, size);
   public static Image ImportAsInt16(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsInt16(buffer, size, spacing);
   public static Image ImportAsInt16(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsInt16(buffer, size, spacing, origin);
   public static Image ImportAsInt16(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsInt16(buffer, size, spacing, origin, direction);
   public static Image ImportAsInt16(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsInt16(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsInt32(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsInt32(buffer, size);
   public static Image ImportAsInt32(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsInt32(buffer, size, spacing);
   public static Image ImportAsInt32(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsInt32(buffer, size, spacing, origin);
   public static Image ImportAsInt32(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsInt32(buffer, size, spacing, origin, direction);
   public static Image ImportAsInt32(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsInt32(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsInt64(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsInt64(buffer, size);
   public static Image ImportAsInt64(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsInt64(buffer, size, spacing);
   public static Image ImportAsInt64(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsInt64(buffer, size, spacing, origin);
   public static Image ImportAsInt64(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsInt64(buffer, size, spacing, origin, direction);
   public static Image ImportAsInt64(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsInt64(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsInt8(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsInt8(buffer, size);
   public static Image ImportAsInt8(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsInt8(buffer, size, spacing);
   public static Image ImportAsInt8(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsInt8(buffer, size, spacing, origin);
   public static Image ImportAsInt8(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsInt8(buffer, size, spacing, origin, direction);
   public static Image ImportAsInt8(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsInt8(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsUInt16(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsUInt16(buffer, size);
   public static Image ImportAsUInt16(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsUInt16(buffer, size, spacing);
   public static Image ImportAsUInt16(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsUInt16(buffer, size, spacing, origin);
   public static Image ImportAsUInt16(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsUInt16(buffer, size, spacing, origin, direction);
   public static Image ImportAsUInt16(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsUInt16(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsUInt32(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsUInt32(buffer, size);
   public static Image ImportAsUInt32(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsUInt32(buffer, size, spacing);
   public static Image ImportAsUInt32(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsUInt32(buffer, size, spacing, origin);
   public static Image ImportAsUInt32(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsUInt32(buffer, size, spacing, origin, direction);
   public static Image ImportAsUInt32(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsUInt32(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsUInt64(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsUInt64(buffer, size);
   public static Image ImportAsUInt64(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsUInt64(buffer, size, spacing);
   public static Image ImportAsUInt64(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsUInt64(buffer, size, spacing, origin);
   public static Image ImportAsUInt64(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsUInt64(buffer, size, spacing, origin, direction);
   public static Image ImportAsUInt64(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsUInt64(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image ImportAsUInt8(this IntPtr buffer, VectorUInt32 size) => SimpleITK.ImportAsUInt8(buffer, size);
   public static Image ImportAsUInt8(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing) => SimpleITK.ImportAsUInt8(buffer, size, spacing);
   public static Image ImportAsUInt8(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin) => SimpleITK.ImportAsUInt8(buffer, size, spacing, origin);
   public static Image ImportAsUInt8(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction) => SimpleITK.ImportAsUInt8(buffer, size, spacing, origin, direction);
   public static Image ImportAsUInt8(this IntPtr buffer, VectorUInt32 size, VectorDouble spacing, VectorDouble origin, VectorDouble direction, uint numberOfComponents) => SimpleITK.ImportAsUInt8(buffer, size, spacing, origin, direction, numberOfComponents);
   public static Image IntensityWindowing(this Image image1) => SimpleITK.IntensityWindowing(image1);
   public static Image IntensityWindowing(this Image image1, double windowMinimum) => SimpleITK.IntensityWindowing(image1, windowMinimum);
   public static Image IntensityWindowing(this Image image1, double windowMinimum, double windowMaximum) => SimpleITK.IntensityWindowing(image1, windowMinimum, windowMaximum);
   public static Image IntensityWindowing(this Image image1, double windowMinimum, double windowMaximum, double outputMinimum) => SimpleITK.IntensityWindowing(image1, windowMinimum, windowMaximum, outputMinimum);
   public static Image IntensityWindowing(this Image image1, double windowMinimum, double windowMaximum, double outputMinimum, double outputMaximum) => SimpleITK.IntensityWindowing(image1, windowMinimum, windowMaximum, outputMinimum, outputMaximum);
   public static Image IntermodesThreshold(this Image image) => SimpleITK.IntermodesThreshold(image);
   public static Image IntermodesThreshold(this Image image, byte insideValue) => SimpleITK.IntermodesThreshold(image, insideValue);
   public static Image IntermodesThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.IntermodesThreshold(image, insideValue, outsideValue);
   public static Image IntermodesThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.IntermodesThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image IntermodesThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.IntermodesThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image IntermodesThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.IntermodesThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image IntermodesThreshold(this Image image, Image maskImage) => SimpleITK.IntermodesThreshold(image, maskImage);
   public static Image IntermodesThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.IntermodesThreshold(image, maskImage, insideValue);
   public static Image IntermodesThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.IntermodesThreshold(image, maskImage, insideValue, outsideValue);
   public static Image IntermodesThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.IntermodesThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image IntermodesThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.IntermodesThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image IntermodesThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.IntermodesThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image InverseDeconvolution(this Image image1, Image image2) => SimpleITK.InverseDeconvolution(image1, image2);
   public static Image InverseDeconvolution(this Image image1, Image image2, double kernelZeroMagnitudeThreshold) => SimpleITK.InverseDeconvolution(image1, image2, kernelZeroMagnitudeThreshold);
   public static Image InverseDeconvolution(this Image image1, Image image2, double kernelZeroMagnitudeThreshold, bool normalize) => SimpleITK.InverseDeconvolution(image1, image2, kernelZeroMagnitudeThreshold, normalize);
   public static Image InverseDeconvolution(this Image image1, Image image2, double kernelZeroMagnitudeThreshold, bool normalize, InverseDeconvolutionImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.InverseDeconvolution(image1, image2, kernelZeroMagnitudeThreshold, normalize, boundaryCondition);
   public static Image InverseDeconvolution(this Image image1, Image image2, double kernelZeroMagnitudeThreshold, bool normalize, InverseDeconvolutionImageFilter.BoundaryConditionType boundaryCondition, InverseDeconvolutionImageFilter.OutputRegionModeType outputRegionMode) => SimpleITK.InverseDeconvolution(image1, image2, kernelZeroMagnitudeThreshold, normalize, boundaryCondition, outputRegionMode);
   public static Image InverseDisplacementField(this Image image1) => SimpleITK.InverseDisplacementField(image1);
   public static Image InverseDisplacementField(this Image image1, VectorUInt32 size) => SimpleITK.InverseDisplacementField(image1, size);
   public static Image InverseDisplacementField(this Image image1, VectorUInt32 size, VectorDouble outputOrigin) => SimpleITK.InverseDisplacementField(image1, size, outputOrigin);
   public static Image InverseDisplacementField(this Image image1, VectorUInt32 size, VectorDouble outputOrigin, VectorDouble outputSpacing) => SimpleITK.InverseDisplacementField(image1, size, outputOrigin, outputSpacing);
   public static Image InverseDisplacementField(this Image image1, VectorUInt32 size, VectorDouble outputOrigin, VectorDouble outputSpacing, uint subsamplingFactor) => SimpleITK.InverseDisplacementField(image1, size, outputOrigin, outputSpacing, subsamplingFactor);
   public static Image InverseFFT(this Image image1) => SimpleITK.InverseFFT(image1);
   public static Image InvertDisplacementField(this Image image1) => SimpleITK.InvertDisplacementField(image1);
   public static Image InvertDisplacementField(this Image image1, uint maximumNumberOfIterations) => SimpleITK.InvertDisplacementField(image1, maximumNumberOfIterations);
   public static Image InvertDisplacementField(this Image image1, uint maximumNumberOfIterations, double maxErrorToleranceThreshold) => SimpleITK.InvertDisplacementField(image1, maximumNumberOfIterations, maxErrorToleranceThreshold);
   public static Image InvertDisplacementField(this Image image1, uint maximumNumberOfIterations, double maxErrorToleranceThreshold, double meanErrorToleranceThreshold) => SimpleITK.InvertDisplacementField(image1, maximumNumberOfIterations, maxErrorToleranceThreshold, meanErrorToleranceThreshold);
   public static Image InvertDisplacementField(this Image image1, uint maximumNumberOfIterations, double maxErrorToleranceThreshold, double meanErrorToleranceThreshold, bool enforceBoundaryCondition) => SimpleITK.InvertDisplacementField(image1, maximumNumberOfIterations, maxErrorToleranceThreshold, meanErrorToleranceThreshold, enforceBoundaryCondition);
   public static Image InvertIntensity(this Image image1) => SimpleITK.InvertIntensity(image1);
   public static Image InvertIntensity(this Image image1, double maximum) => SimpleITK.InvertIntensity(image1, maximum);
   public static Image IsoContourDistance(this Image image1) => SimpleITK.IsoContourDistance(image1);
   public static Image IsoContourDistance(this Image image1, double levelSetValue) => SimpleITK.IsoContourDistance(image1, levelSetValue);
   public static Image IsoContourDistance(this Image image1, double levelSetValue, double farValue) => SimpleITK.IsoContourDistance(image1, levelSetValue, farValue);
   public static Image IsoDataThreshold(this Image image) => SimpleITK.IsoDataThreshold(image);
   public static Image IsoDataThreshold(this Image image, byte insideValue) => SimpleITK.IsoDataThreshold(image, insideValue);
   public static Image IsoDataThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.IsoDataThreshold(image, insideValue, outsideValue);
   public static Image IsoDataThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.IsoDataThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image IsoDataThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.IsoDataThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image IsoDataThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.IsoDataThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image IsoDataThreshold(this Image image, Image maskImage) => SimpleITK.IsoDataThreshold(image, maskImage);
   public static Image IsoDataThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.IsoDataThreshold(image, maskImage, insideValue);
   public static Image IsoDataThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.IsoDataThreshold(image, maskImage, insideValue, outsideValue);
   public static Image IsoDataThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.IsoDataThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image IsoDataThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.IsoDataThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image IsoDataThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.IsoDataThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image IsolatedConnected(this Image image1) => SimpleITK.IsolatedConnected(image1);
   public static Image IsolatedConnected(this Image image1, VectorUInt32 seed1) => SimpleITK.IsolatedConnected(image1, seed1);
   public static Image IsolatedConnected(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2) => SimpleITK.IsolatedConnected(image1, seed1, seed2);
   public static Image IsolatedConnected(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double lower) => SimpleITK.IsolatedConnected(image1, seed1, seed2, lower);
   public static Image IsolatedConnected(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double lower, double upper) => SimpleITK.IsolatedConnected(image1, seed1, seed2, lower, upper);
   public static Image IsolatedConnected(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double lower, double upper, byte replaceValue) => SimpleITK.IsolatedConnected(image1, seed1, seed2, lower, upper, replaceValue);
   public static Image IsolatedConnected(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double lower, double upper, byte replaceValue, double isolatedValueTolerance) => SimpleITK.IsolatedConnected(image1, seed1, seed2, lower, upper, replaceValue, isolatedValueTolerance);
   public static Image IsolatedConnected(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double lower, double upper, byte replaceValue, double isolatedValueTolerance, bool findUpperThreshold) => SimpleITK.IsolatedConnected(image1, seed1, seed2, lower, upper, replaceValue, isolatedValueTolerance, findUpperThreshold);
   public static Image IsolatedWatershed(this Image image1) => SimpleITK.IsolatedWatershed(image1);
   public static Image IsolatedWatershed(this Image image1, VectorUInt32 seed1) => SimpleITK.IsolatedWatershed(image1, seed1);
   public static Image IsolatedWatershed(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2) => SimpleITK.IsolatedWatershed(image1, seed1, seed2);
   public static Image IsolatedWatershed(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double threshold) => SimpleITK.IsolatedWatershed(image1, seed1, seed2, threshold);
   public static Image IsolatedWatershed(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double threshold, double upperValueLimit) => SimpleITK.IsolatedWatershed(image1, seed1, seed2, threshold, upperValueLimit);
   public static Image IsolatedWatershed(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double threshold, double upperValueLimit, double isolatedValueTolerance) => SimpleITK.IsolatedWatershed(image1, seed1, seed2, threshold, upperValueLimit, isolatedValueTolerance);
   public static Image IsolatedWatershed(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double threshold, double upperValueLimit, double isolatedValueTolerance, byte replaceValue1) => SimpleITK.IsolatedWatershed(image1, seed1, seed2, threshold, upperValueLimit, isolatedValueTolerance, replaceValue1);
   public static Image IsolatedWatershed(this Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double threshold, double upperValueLimit, double isolatedValueTolerance, byte replaceValue1, byte replaceValue2) => SimpleITK.IsolatedWatershed(image1, seed1, seed2, threshold, upperValueLimit, isolatedValueTolerance, replaceValue1, replaceValue2);
   public static Image IterativeInverseDisplacementField(this Image image1) => SimpleITK.IterativeInverseDisplacementField(image1);
   public static Image IterativeInverseDisplacementField(this Image image1, uint numberOfIterations) => SimpleITK.IterativeInverseDisplacementField(image1, numberOfIterations);
   public static Image IterativeInverseDisplacementField(this Image image1, uint numberOfIterations, double stopValue) => SimpleITK.IterativeInverseDisplacementField(image1, numberOfIterations, stopValue);
   public static Image JoinSeries(this Image image1) => SimpleITK.JoinSeries(image1);
   public static Image JoinSeries(this Image image1, double origin) => SimpleITK.JoinSeries(image1, origin);
   public static Image JoinSeries(this Image image1, double origin, double spacing) => SimpleITK.JoinSeries(image1, origin, spacing);
   public static Image JoinSeries(this Image image1, Image image2) => SimpleITK.JoinSeries(image1, image2);
   public static Image JoinSeries(this Image image1, Image image2, double origin) => SimpleITK.JoinSeries(image1, image2, origin);
   public static Image JoinSeries(this Image image1, Image image2, double origin, double spacing) => SimpleITK.JoinSeries(image1, image2, origin, spacing);
   public static Image JoinSeries(this Image image1, Image image2, Image image3) => SimpleITK.JoinSeries(image1, image2, image3);
   public static Image JoinSeries(this Image image1, Image image2, Image image3, double origin) => SimpleITK.JoinSeries(image1, image2, image3, origin);
   public static Image JoinSeries(this Image image1, Image image2, Image image3, double origin, double spacing) => SimpleITK.JoinSeries(image1, image2, image3, origin, spacing);
   public static Image JoinSeries(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.JoinSeries(image1, image2, image3, image4);
   public static Image JoinSeries(this Image image1, Image image2, Image image3, Image image4, double origin) => SimpleITK.JoinSeries(image1, image2, image3, image4, origin);
   public static Image JoinSeries(this Image image1, Image image2, Image image3, Image image4, double origin, double spacing) => SimpleITK.JoinSeries(image1, image2, image3, image4, origin, spacing);
   public static Image JoinSeries(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.JoinSeries(image1, image2, image3, image4, image5);
   public static Image JoinSeries(this Image image1, Image image2, Image image3, Image image4, Image image5, double origin) => SimpleITK.JoinSeries(image1, image2, image3, image4, image5, origin);
   public static Image JoinSeries(this Image image1, Image image2, Image image3, Image image4, Image image5, double origin, double spacing) => SimpleITK.JoinSeries(image1, image2, image3, image4, image5, origin, spacing);
   public static Image JoinSeries(this VectorOfImage images) => SimpleITK.JoinSeries(images);
   public static Image JoinSeries(this VectorOfImage images, double origin) => SimpleITK.JoinSeries(images, origin);
   public static Image JoinSeries(this VectorOfImage images, double origin, double spacing) => SimpleITK.JoinSeries(images, origin, spacing);
   public static Image KittlerIllingworthThreshold(this Image image) => SimpleITK.KittlerIllingworthThreshold(image);
   public static Image KittlerIllingworthThreshold(this Image image, byte insideValue) => SimpleITK.KittlerIllingworthThreshold(image, insideValue);
   public static Image KittlerIllingworthThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.KittlerIllingworthThreshold(image, insideValue, outsideValue);
   public static Image KittlerIllingworthThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.KittlerIllingworthThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image KittlerIllingworthThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.KittlerIllingworthThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image KittlerIllingworthThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.KittlerIllingworthThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image KittlerIllingworthThreshold(this Image image, Image maskImage) => SimpleITK.KittlerIllingworthThreshold(image, maskImage);
   public static Image KittlerIllingworthThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.KittlerIllingworthThreshold(image, maskImage, insideValue);
   public static Image KittlerIllingworthThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.KittlerIllingworthThreshold(image, maskImage, insideValue, outsideValue);
   public static Image KittlerIllingworthThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.KittlerIllingworthThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image KittlerIllingworthThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.KittlerIllingworthThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image KittlerIllingworthThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.KittlerIllingworthThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image LabelContour(this Image image1) => SimpleITK.LabelContour(image1);
   public static Image LabelContour(this Image image1, bool fullyConnected) => SimpleITK.LabelContour(image1, fullyConnected);
   public static Image LabelContour(this Image image1, bool fullyConnected, double backgroundValue) => SimpleITK.LabelContour(image1, fullyConnected, backgroundValue);
   public static Image LabelImageToLabelMap(this Image image1) => SimpleITK.LabelImageToLabelMap(image1);
   public static Image LabelImageToLabelMap(this Image image1, double backgroundValue) => SimpleITK.LabelImageToLabelMap(image1, backgroundValue);
   public static Image LabelMapContourOverlay(this Image labelMapImage, Image featureImage) => SimpleITK.LabelMapContourOverlay(labelMapImage, featureImage);
   public static Image LabelMapContourOverlay(this Image labelMapImage, Image featureImage, double opacity) => SimpleITK.LabelMapContourOverlay(labelMapImage, featureImage, opacity);
   public static Image LabelMapContourOverlay(this Image labelMapImage, Image featureImage, double opacity, VectorUInt32 dilationRadius) => SimpleITK.LabelMapContourOverlay(labelMapImage, featureImage, opacity, dilationRadius);
   public static Image LabelMapContourOverlay(this Image labelMapImage, Image featureImage, double opacity, VectorUInt32 dilationRadius, VectorUInt32 contourThickness) => SimpleITK.LabelMapContourOverlay(labelMapImage, featureImage, opacity, dilationRadius, contourThickness);
   public static Image LabelMapContourOverlay(this Image labelMapImage, Image featureImage, double opacity, VectorUInt32 dilationRadius, VectorUInt32 contourThickness, uint sliceDimension) => SimpleITK.LabelMapContourOverlay(labelMapImage, featureImage, opacity, dilationRadius, contourThickness, sliceDimension);
   public static Image LabelMapContourOverlay(this Image labelMapImage, Image featureImage, double opacity, VectorUInt32 dilationRadius, VectorUInt32 contourThickness, uint sliceDimension, LabelMapContourOverlayImageFilter.ContourTypeType contourType) => SimpleITK.LabelMapContourOverlay(labelMapImage, featureImage, opacity, dilationRadius, contourThickness, sliceDimension, contourType);
   public static Image LabelMapContourOverlay(this Image labelMapImage, Image featureImage, double opacity, VectorUInt32 dilationRadius, VectorUInt32 contourThickness, uint sliceDimension, LabelMapContourOverlayImageFilter.ContourTypeType contourType, LabelMapContourOverlayImageFilter.PriorityType priority, VectorUInt8 colormap) => SimpleITK.LabelMapContourOverlay(labelMapImage, featureImage, opacity, dilationRadius, contourThickness, sliceDimension, contourType, priority, colormap);
   public static Image LabelMapContourOverlay(this Image labelMapImage, Image featureImage, double opacity, VectorUInt32 dilationRadius, VectorUInt32 contourThickness, uint sliceDimension, LabelMapContourOverlayImageFilter.ContourTypeType contourType, LabelMapContourOverlayImageFilter.PriorityType priority) => SimpleITK.LabelMapContourOverlay(labelMapImage, featureImage, opacity, dilationRadius, contourThickness, sliceDimension, contourType, priority);
   public static Image LabelMapMask(this Image labelMapImage, Image featureImage) => SimpleITK.LabelMapMask(labelMapImage, featureImage);
   public static Image LabelMapMask(this Image labelMapImage, Image featureImage, ulong label) => SimpleITK.LabelMapMask(labelMapImage, featureImage, label);
   public static Image LabelMapMask(this Image labelMapImage, Image featureImage, ulong label, double backgroundValue) => SimpleITK.LabelMapMask(labelMapImage, featureImage, label, backgroundValue);
   public static Image LabelMapMask(this Image labelMapImage, Image featureImage, ulong label, double backgroundValue, bool negated) => SimpleITK.LabelMapMask(labelMapImage, featureImage, label, backgroundValue, negated);
   public static Image LabelMapMask(this Image labelMapImage, Image featureImage, ulong label, double backgroundValue, bool negated, bool crop) => SimpleITK.LabelMapMask(labelMapImage, featureImage, label, backgroundValue, negated, crop);
   public static Image LabelMapMask(this Image labelMapImage, Image featureImage, ulong label, double backgroundValue, bool negated, bool crop, VectorUInt32 cropBorder) => SimpleITK.LabelMapMask(labelMapImage, featureImage, label, backgroundValue, negated, crop, cropBorder);
   public static Image LabelMapOverlay(this Image labelMapImage, Image featureImage) => SimpleITK.LabelMapOverlay(labelMapImage, featureImage);
   public static Image LabelMapOverlay(this Image labelMapImage, Image featureImage, double opacity) => SimpleITK.LabelMapOverlay(labelMapImage, featureImage, opacity);
   public static Image LabelMapOverlay(this Image labelMapImage, Image featureImage, double opacity, VectorUInt8 colormap) => SimpleITK.LabelMapOverlay(labelMapImage, featureImage, opacity, colormap);
   public static Image LabelMapToBinary(this Image image1) => SimpleITK.LabelMapToBinary(image1);
   public static Image LabelMapToBinary(this Image image1, double backgroundValue) => SimpleITK.LabelMapToBinary(image1, backgroundValue);
   public static Image LabelMapToBinary(this Image image1, double backgroundValue, double foregroundValue) => SimpleITK.LabelMapToBinary(image1, backgroundValue, foregroundValue);
   public static Image LabelMapToLabel(this Image image1) => SimpleITK.LabelMapToLabel(image1);
   public static Image LabelMapToRGB(this Image image1) => SimpleITK.LabelMapToRGB(image1);
   public static Image LabelMapToRGB(this Image image1, VectorUInt8 colormap) => SimpleITK.LabelMapToRGB(image1, colormap);
   public static Image LabelOverlay(this Image image, Image labelImage) => SimpleITK.LabelOverlay(image, labelImage);
   public static Image LabelOverlay(this Image image, Image labelImage, double opacity) => SimpleITK.LabelOverlay(image, labelImage, opacity);
   public static Image LabelOverlay(this Image image, Image labelImage, double opacity, double backgroundValue) => SimpleITK.LabelOverlay(image, labelImage, opacity, backgroundValue);
   public static Image LabelOverlay(this Image image, Image labelImage, double opacity, double backgroundValue, VectorUInt8 colormap) => SimpleITK.LabelOverlay(image, labelImage, opacity, backgroundValue, colormap);
   public static Image LabelToRGB(this Image image1) => SimpleITK.LabelToRGB(image1);
   public static Image LabelToRGB(this Image image1, double backgroundValue) => SimpleITK.LabelToRGB(image1, backgroundValue);
   public static Image LabelToRGB(this Image image1, double backgroundValue, VectorUInt8 colormap) => SimpleITK.LabelToRGB(image1, backgroundValue, colormap);
   public static Image LabelUniqueLabelMap(this Image image1) => SimpleITK.LabelUniqueLabelMap(image1);
   public static Image LabelUniqueLabelMap(this Image image1, bool reverseOrdering) => SimpleITK.LabelUniqueLabelMap(image1, reverseOrdering);
   public static Image LabelVoting(this Image image1) => SimpleITK.LabelVoting(image1);
   public static Image LabelVoting(this Image image1, Image image2) => SimpleITK.LabelVoting(image1, image2);
   public static Image LabelVoting(this Image image1, Image image2, Image image3) => SimpleITK.LabelVoting(image1, image2, image3);
   public static Image LabelVoting(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.LabelVoting(image1, image2, image3, image4);
   public static Image LabelVoting(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.LabelVoting(image1, image2, image3, image4, image5);
   public static Image LabelVoting(this Image image1, Image image2, Image image3, Image image4, Image image5, ulong labelForUndecidedPixels) => SimpleITK.LabelVoting(image1, image2, image3, image4, image5, labelForUndecidedPixels);
   public static Image LabelVoting(this Image image1, Image image2, Image image3, Image image4, ulong labelForUndecidedPixels) => SimpleITK.LabelVoting(image1, image2, image3, image4, labelForUndecidedPixels);
   public static Image LabelVoting(this Image image1, Image image2, Image image3, ulong labelForUndecidedPixels) => SimpleITK.LabelVoting(image1, image2, image3, labelForUndecidedPixels);
   public static Image LabelVoting(this Image image1, Image image2, ulong labelForUndecidedPixels) => SimpleITK.LabelVoting(image1, image2, labelForUndecidedPixels);
   public static Image LabelVoting(this Image image1, ulong labelForUndecidedPixels) => SimpleITK.LabelVoting(image1, labelForUndecidedPixels);
   public static Image LabelVoting(this VectorOfImage images) => SimpleITK.LabelVoting(images);
   public static Image LabelVoting(this VectorOfImage images, ulong labelForUndecidedPixels) => SimpleITK.LabelVoting(images, labelForUndecidedPixels);
   public static Image LandweberDeconvolution(this Image image1, Image image2) => SimpleITK.LandweberDeconvolution(image1, image2);
   public static Image LandweberDeconvolution(this Image image1, Image image2, double alpha) => SimpleITK.LandweberDeconvolution(image1, image2, alpha);
   public static Image LandweberDeconvolution(this Image image1, Image image2, double alpha, int numberOfIterations) => SimpleITK.LandweberDeconvolution(image1, image2, alpha, numberOfIterations);
   public static Image LandweberDeconvolution(this Image image1, Image image2, double alpha, int numberOfIterations, bool normalize) => SimpleITK.LandweberDeconvolution(image1, image2, alpha, numberOfIterations, normalize);
   public static Image LandweberDeconvolution(this Image image1, Image image2, double alpha, int numberOfIterations, bool normalize, LandweberDeconvolutionImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.LandweberDeconvolution(image1, image2, alpha, numberOfIterations, normalize, boundaryCondition);
   public static Image LandweberDeconvolution(this Image image1, Image image2, double alpha, int numberOfIterations, bool normalize, LandweberDeconvolutionImageFilter.BoundaryConditionType boundaryCondition, LandweberDeconvolutionImageFilter.OutputRegionModeType outputRegionMode) => SimpleITK.LandweberDeconvolution(image1, image2, alpha, numberOfIterations, normalize, boundaryCondition, outputRegionMode);
   public static Image Laplacian(this Image image1) => SimpleITK.Laplacian(image1);
   public static Image Laplacian(this Image image1, bool useImageSpacing) => SimpleITK.Laplacian(image1, useImageSpacing);
   public static Image LaplacianRecursiveGaussian(this Image image1) => SimpleITK.LaplacianRecursiveGaussian(image1);
   public static Image LaplacianRecursiveGaussian(this Image image1, double sigma) => SimpleITK.LaplacianRecursiveGaussian(image1, sigma);
   public static Image LaplacianRecursiveGaussian(this Image image1, double sigma, bool normalizeAcrossScale) => SimpleITK.LaplacianRecursiveGaussian(image1, sigma, normalizeAcrossScale);
   public static Image LaplacianSegmentationLevelSet(this Image initialImage, Image featureImage) => SimpleITK.LaplacianSegmentationLevelSet(initialImage, featureImage);
   public static Image LaplacianSegmentationLevelSet(this Image initialImage, Image featureImage, double maximumRMSError) => SimpleITK.LaplacianSegmentationLevelSet(initialImage, featureImage, maximumRMSError);
   public static Image LaplacianSegmentationLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, double propagationScaling) => SimpleITK.LaplacianSegmentationLevelSet(initialImage, featureImage, maximumRMSError, propagationScaling);
   public static Image LaplacianSegmentationLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, double propagationScaling, double curvatureScaling) => SimpleITK.LaplacianSegmentationLevelSet(initialImage, featureImage, maximumRMSError, propagationScaling, curvatureScaling);
   public static Image LaplacianSegmentationLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, double propagationScaling, double curvatureScaling, uint numberOfIterations) => SimpleITK.LaplacianSegmentationLevelSet(initialImage, featureImage, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations);
   public static Image LaplacianSegmentationLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, double propagationScaling, double curvatureScaling, uint numberOfIterations, bool reverseExpansionDirection) => SimpleITK.LaplacianSegmentationLevelSet(initialImage, featureImage, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations, reverseExpansionDirection);
   public static Image LaplacianSharpening(this Image image1) => SimpleITK.LaplacianSharpening(image1);
   public static Image LaplacianSharpening(this Image image1, bool useImageSpacing) => SimpleITK.LaplacianSharpening(image1, useImageSpacing);
   public static Image Less(this double constant, Image image2) => SimpleITK.Less(constant, image2);
   public static Image Less(this double constant, Image image2, byte backgroundValue) => SimpleITK.Less(constant, image2, backgroundValue);
   public static Image Less(this double constant, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.Less(constant, image2, backgroundValue, foregroundValue);
   public static Image Less(this Image image1, double constant) => SimpleITK.Less(image1, constant);
   public static Image Less(this Image image1, double constant, byte backgroundValue) => SimpleITK.Less(image1, constant, backgroundValue);
   public static Image Less(this Image image1, double constant, byte backgroundValue, byte foregroundValue) => SimpleITK.Less(image1, constant, backgroundValue, foregroundValue);
   public static Image Less(this Image image1, Image image2) => SimpleITK.Less(image1, image2);
   public static Image Less(this Image image1, Image image2, byte backgroundValue) => SimpleITK.Less(image1, image2, backgroundValue);
   public static Image Less(this Image image1, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.Less(image1, image2, backgroundValue, foregroundValue);
   public static Image LessEqual(this double constant, Image image2) => SimpleITK.LessEqual(constant, image2);
   public static Image LessEqual(this double constant, Image image2, byte backgroundValue) => SimpleITK.LessEqual(constant, image2, backgroundValue);
   public static Image LessEqual(this double constant, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.LessEqual(constant, image2, backgroundValue, foregroundValue);
   public static Image LessEqual(this Image image1, double constant) => SimpleITK.LessEqual(image1, constant);
   public static Image LessEqual(this Image image1, double constant, byte backgroundValue) => SimpleITK.LessEqual(image1, constant, backgroundValue);
   public static Image LessEqual(this Image image1, double constant, byte backgroundValue, byte foregroundValue) => SimpleITK.LessEqual(image1, constant, backgroundValue, foregroundValue);
   public static Image LessEqual(this Image image1, Image image2) => SimpleITK.LessEqual(image1, image2);
   public static Image LessEqual(this Image image1, Image image2, byte backgroundValue) => SimpleITK.LessEqual(image1, image2, backgroundValue);
   public static Image LessEqual(this Image image1, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.LessEqual(image1, image2, backgroundValue, foregroundValue);
   public static Image LiThreshold(this Image image) => SimpleITK.LiThreshold(image);
   public static Image LiThreshold(this Image image, byte insideValue) => SimpleITK.LiThreshold(image, insideValue);
   public static Image LiThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.LiThreshold(image, insideValue, outsideValue);
   public static Image LiThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.LiThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image LiThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.LiThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image LiThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.LiThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image LiThreshold(this Image image, Image maskImage) => SimpleITK.LiThreshold(image, maskImage);
   public static Image LiThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.LiThreshold(image, maskImage, insideValue);
   public static Image LiThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.LiThreshold(image, maskImage, insideValue, outsideValue);
   public static Image LiThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.LiThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image LiThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.LiThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image LiThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.LiThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image Log(this Image image1) => SimpleITK.Log(image1);
   public static Image Log10(this Image image1) => SimpleITK.Log10(image1);
   public static Image MagnitudeAndPhaseToComplex(this double constant, Image image2) => SimpleITK.MagnitudeAndPhaseToComplex(constant, image2);
   public static Image MagnitudeAndPhaseToComplex(this Image image1, double constant) => SimpleITK.MagnitudeAndPhaseToComplex(image1, constant);
   public static Image MagnitudeAndPhaseToComplex(this Image image1, Image image2) => SimpleITK.MagnitudeAndPhaseToComplex(image1, image2);
   public static Image Mask(this Image image, Image maskImage) => SimpleITK.Mask(image, maskImage);
   public static Image Mask(this Image image, Image maskImage, double outsideValue) => SimpleITK.Mask(image, maskImage, outsideValue);
   public static Image Mask(this Image image, Image maskImage, double outsideValue, double maskingValue) => SimpleITK.Mask(image, maskImage, outsideValue, maskingValue);
   public static Image MaskedAssign(this Image image, Image maskImage) => SimpleITK.MaskedAssign(image, maskImage);
   public static Image MaskedAssign(this Image image, Image maskImage, double assignConstant) => SimpleITK.MaskedAssign(image, maskImage, assignConstant);
   public static Image MaskedAssign(this Image image, Image maskImage, Image assignImage) => SimpleITK.MaskedAssign(image, maskImage, assignImage);
   public static Image MaskedAssign(this Image image, Image maskImage, Image assignImage, double assignConstant) => SimpleITK.MaskedAssign(image, maskImage, assignImage, assignConstant);
   public static Image MaskedFFTNormalizedCorrelation(this Image fixedImage, Image movingImage, Image fixedImageMask, Image movingImageMask) => SimpleITK.MaskedFFTNormalizedCorrelation(fixedImage, movingImage, fixedImageMask, movingImageMask);
   public static Image MaskedFFTNormalizedCorrelation(this Image fixedImage, Image movingImage, Image fixedImageMask, Image movingImageMask, ulong requiredNumberOfOverlappingPixels) => SimpleITK.MaskedFFTNormalizedCorrelation(fixedImage, movingImage, fixedImageMask, movingImageMask, requiredNumberOfOverlappingPixels);
   public static Image MaskedFFTNormalizedCorrelation(this Image fixedImage, Image movingImage, Image fixedImageMask, Image movingImageMask, ulong requiredNumberOfOverlappingPixels, float requiredFractionOfOverlappingPixels) => SimpleITK.MaskedFFTNormalizedCorrelation(fixedImage, movingImage, fixedImageMask, movingImageMask, requiredNumberOfOverlappingPixels, requiredFractionOfOverlappingPixels);
   public static Image MaskNegated(this Image image, Image maskImage) => SimpleITK.MaskNegated(image, maskImage);
   public static Image MaskNegated(this Image image, Image maskImage, double outsideValue) => SimpleITK.MaskNegated(image, maskImage, outsideValue);
   public static Image MaskNegated(this Image image, Image maskImage, double outsideValue, double maskingValue) => SimpleITK.MaskNegated(image, maskImage, outsideValue, maskingValue);
   public static Image Maximum(this double constant, Image image2) => SimpleITK.Maximum(constant, image2);
   public static Image Maximum(this Image image1, double constant) => SimpleITK.Maximum(image1, constant);
   public static Image Maximum(this Image image1, Image image2) => SimpleITK.Maximum(image1, image2);
   public static Image MaximumEntropyThreshold(this Image image) => SimpleITK.MaximumEntropyThreshold(image);
   public static Image MaximumEntropyThreshold(this Image image, byte insideValue) => SimpleITK.MaximumEntropyThreshold(image, insideValue);
   public static Image MaximumEntropyThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.MaximumEntropyThreshold(image, insideValue, outsideValue);
   public static Image MaximumEntropyThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.MaximumEntropyThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image MaximumEntropyThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.MaximumEntropyThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image MaximumEntropyThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.MaximumEntropyThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image MaximumEntropyThreshold(this Image image, Image maskImage) => SimpleITK.MaximumEntropyThreshold(image, maskImage);
   public static Image MaximumEntropyThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.MaximumEntropyThreshold(image, maskImage, insideValue);
   public static Image MaximumEntropyThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.MaximumEntropyThreshold(image, maskImage, insideValue, outsideValue);
   public static Image MaximumEntropyThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.MaximumEntropyThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image MaximumEntropyThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.MaximumEntropyThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image MaximumEntropyThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.MaximumEntropyThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image MaximumProjection(this Image image1) => SimpleITK.MaximumProjection(image1);
   public static Image MaximumProjection(this Image image1, uint projectionDimension) => SimpleITK.MaximumProjection(image1, projectionDimension);
   public static Image Mean(this Image image1) => SimpleITK.Mean(image1);
   public static Image Mean(this Image image1, VectorUInt32 radius) => SimpleITK.Mean(image1, radius);
   public static Image MeanProjection(this Image image1) => SimpleITK.MeanProjection(image1);
   public static Image MeanProjection(this Image image1, uint projectionDimension) => SimpleITK.MeanProjection(image1, projectionDimension);
   public static Image Median(this Image image1) => SimpleITK.Median(image1);
   public static Image Median(this Image image1, VectorUInt32 radius) => SimpleITK.Median(image1, radius);
   public static Image MedianProjection(this Image image1) => SimpleITK.MedianProjection(image1);
   public static Image MedianProjection(this Image image1, uint projectionDimension) => SimpleITK.MedianProjection(image1, projectionDimension);
   public static Image MergeLabelMap(this Image image1) => SimpleITK.MergeLabelMap(image1);
   public static Image MergeLabelMap(this Image image1, Image image2) => SimpleITK.MergeLabelMap(image1, image2);
   public static Image MergeLabelMap(this Image image1, Image image2, Image image3) => SimpleITK.MergeLabelMap(image1, image2, image3);
   public static Image MergeLabelMap(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.MergeLabelMap(image1, image2, image3, image4);
   public static Image MergeLabelMap(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.MergeLabelMap(image1, image2, image3, image4, image5);
   public static Image MergeLabelMap(this Image image1, Image image2, Image image3, Image image4, Image image5, MergeLabelMapFilter.MethodType method) => SimpleITK.MergeLabelMap(image1, image2, image3, image4, image5, method);
   public static Image MergeLabelMap(this Image image1, Image image2, Image image3, Image image4, MergeLabelMapFilter.MethodType method) => SimpleITK.MergeLabelMap(image1, image2, image3, image4, method);
   public static Image MergeLabelMap(this Image image1, Image image2, Image image3, MergeLabelMapFilter.MethodType method) => SimpleITK.MergeLabelMap(image1, image2, image3, method);
   public static Image MergeLabelMap(this Image image1, Image image2, MergeLabelMapFilter.MethodType method) => SimpleITK.MergeLabelMap(image1, image2, method);
   public static Image MergeLabelMap(this Image image1, MergeLabelMapFilter.MethodType method) => SimpleITK.MergeLabelMap(image1, method);
   public static Image MergeLabelMap(this VectorOfImage images) => SimpleITK.MergeLabelMap(images);
   public static Image MergeLabelMap(this VectorOfImage images, MergeLabelMapFilter.MethodType method) => SimpleITK.MergeLabelMap(images, method);
   public static Image Minimum(this double constant, Image image2) => SimpleITK.Minimum(constant, image2);
   public static Image Minimum(this Image image1, double constant) => SimpleITK.Minimum(image1, constant);
   public static Image Minimum(this Image image1, Image image2) => SimpleITK.Minimum(image1, image2);
   public static Image MinimumProjection(this Image image1) => SimpleITK.MinimumProjection(image1);
   public static Image MinimumProjection(this Image image1, uint projectionDimension) => SimpleITK.MinimumProjection(image1, projectionDimension);
   public static Image MinMaxCurvatureFlow(this Image image1) => SimpleITK.MinMaxCurvatureFlow(image1);
   public static Image MinMaxCurvatureFlow(this Image image1, double timeStep) => SimpleITK.MinMaxCurvatureFlow(image1, timeStep);
   public static Image MinMaxCurvatureFlow(this Image image1, double timeStep, uint numberOfIterations) => SimpleITK.MinMaxCurvatureFlow(image1, timeStep, numberOfIterations);
   public static Image MinMaxCurvatureFlow(this Image image1, double timeStep, uint numberOfIterations, int stencilRadius) => SimpleITK.MinMaxCurvatureFlow(image1, timeStep, numberOfIterations, stencilRadius);
   public static Image MirrorPad(this Image image1) => SimpleITK.MirrorPad(image1);
   public static Image MirrorPad(this Image image1, VectorUInt32 padLowerBound) => SimpleITK.MirrorPad(image1, padLowerBound);
   public static Image MirrorPad(this Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) => SimpleITK.MirrorPad(image1, padLowerBound, padUpperBound);
   public static Image MirrorPad(this Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound, double decayBase) => SimpleITK.MirrorPad(image1, padLowerBound, padUpperBound, decayBase);
   public static Image Modulus(this Image image1, Image image2) => SimpleITK.Modulus(image1, image2);
   public static Image Modulus(this Image image1, uint constant) => SimpleITK.Modulus(image1, constant);
   public static Image Modulus(this uint constant, Image image2) => SimpleITK.Modulus(constant, image2);
   public static Image MomentsThreshold(this Image image) => SimpleITK.MomentsThreshold(image);
   public static Image MomentsThreshold(this Image image, byte insideValue) => SimpleITK.MomentsThreshold(image, insideValue);
   public static Image MomentsThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.MomentsThreshold(image, insideValue, outsideValue);
   public static Image MomentsThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.MomentsThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image MomentsThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.MomentsThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image MomentsThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.MomentsThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image MomentsThreshold(this Image image, Image maskImage) => SimpleITK.MomentsThreshold(image, maskImage);
   public static Image MomentsThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.MomentsThreshold(image, maskImage, insideValue);
   public static Image MomentsThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.MomentsThreshold(image, maskImage, insideValue, outsideValue);
   public static Image MomentsThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.MomentsThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image MomentsThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.MomentsThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image MomentsThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.MomentsThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image MorphologicalGradient(this Image image1) => SimpleITK.MorphologicalGradient(image1);
   public static Image MorphologicalGradient(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.MorphologicalGradient(image1, kernelRadius);
   public static Image MorphologicalGradient(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.MorphologicalGradient(image1, kernelRadius, kernelType);
   public static Image MorphologicalWatershed(this Image image1) => SimpleITK.MorphologicalWatershed(image1);
   public static Image MorphologicalWatershed(this Image image1, double level) => SimpleITK.MorphologicalWatershed(image1, level);
   public static Image MorphologicalWatershed(this Image image1, double level, bool markWatershedLine) => SimpleITK.MorphologicalWatershed(image1, level, markWatershedLine);
   public static Image MorphologicalWatershed(this Image image1, double level, bool markWatershedLine, bool fullyConnected) => SimpleITK.MorphologicalWatershed(image1, level, markWatershedLine, fullyConnected);
   public static Image MorphologicalWatershedFromMarkers(this Image image, Image markerImage) => SimpleITK.MorphologicalWatershedFromMarkers(image, markerImage);
   public static Image MorphologicalWatershedFromMarkers(this Image image, Image markerImage, bool markWatershedLine) => SimpleITK.MorphologicalWatershedFromMarkers(image, markerImage, markWatershedLine);
   public static Image MorphologicalWatershedFromMarkers(this Image image, Image markerImage, bool markWatershedLine, bool fullyConnected) => SimpleITK.MorphologicalWatershedFromMarkers(image, markerImage, markWatershedLine, fullyConnected);
   public static Image MultiLabelSTAPLE(this Image image1) => SimpleITK.MultiLabelSTAPLE(image1);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2) => SimpleITK.MultiLabelSTAPLE(image1, image2);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, image5);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5, ulong labelForUndecidedPixels) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, image5, labelForUndecidedPixels);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5, ulong labelForUndecidedPixels, float terminationUpdateThreshold) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, image5, labelForUndecidedPixels, terminationUpdateThreshold);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, image5, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations, VectorFloat priorProbabilities) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, image5, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations, priorProbabilities);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, ulong labelForUndecidedPixels) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, labelForUndecidedPixels);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, ulong labelForUndecidedPixels, float terminationUpdateThreshold) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, labelForUndecidedPixels, terminationUpdateThreshold);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, Image image4, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations, VectorFloat priorProbabilities) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, image4, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations, priorProbabilities);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, ulong labelForUndecidedPixels) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, labelForUndecidedPixels);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, ulong labelForUndecidedPixels, float terminationUpdateThreshold) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, labelForUndecidedPixels, terminationUpdateThreshold);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, Image image3, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations, VectorFloat priorProbabilities) => SimpleITK.MultiLabelSTAPLE(image1, image2, image3, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations, priorProbabilities);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, ulong labelForUndecidedPixels) => SimpleITK.MultiLabelSTAPLE(image1, image2, labelForUndecidedPixels);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, ulong labelForUndecidedPixels, float terminationUpdateThreshold) => SimpleITK.MultiLabelSTAPLE(image1, image2, labelForUndecidedPixels, terminationUpdateThreshold);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations) => SimpleITK.MultiLabelSTAPLE(image1, image2, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations);
   public static Image MultiLabelSTAPLE(this Image image1, Image image2, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations, VectorFloat priorProbabilities) => SimpleITK.MultiLabelSTAPLE(image1, image2, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations, priorProbabilities);
   public static Image MultiLabelSTAPLE(this Image image1, ulong labelForUndecidedPixels) => SimpleITK.MultiLabelSTAPLE(image1, labelForUndecidedPixels);
   public static Image MultiLabelSTAPLE(this Image image1, ulong labelForUndecidedPixels, float terminationUpdateThreshold) => SimpleITK.MultiLabelSTAPLE(image1, labelForUndecidedPixels, terminationUpdateThreshold);
   public static Image MultiLabelSTAPLE(this Image image1, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations) => SimpleITK.MultiLabelSTAPLE(image1, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations);
   public static Image MultiLabelSTAPLE(this Image image1, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations, VectorFloat priorProbabilities) => SimpleITK.MultiLabelSTAPLE(image1, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations, priorProbabilities);
   public static Image MultiLabelSTAPLE(this VectorOfImage images) => SimpleITK.MultiLabelSTAPLE(images);
   public static Image MultiLabelSTAPLE(this VectorOfImage images, ulong labelForUndecidedPixels) => SimpleITK.MultiLabelSTAPLE(images, labelForUndecidedPixels);
   public static Image MultiLabelSTAPLE(this VectorOfImage images, ulong labelForUndecidedPixels, float terminationUpdateThreshold) => SimpleITK.MultiLabelSTAPLE(images, labelForUndecidedPixels, terminationUpdateThreshold);
   public static Image MultiLabelSTAPLE(this VectorOfImage images, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations) => SimpleITK.MultiLabelSTAPLE(images, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations);
   public static Image MultiLabelSTAPLE(this VectorOfImage images, ulong labelForUndecidedPixels, float terminationUpdateThreshold, uint maximumNumberOfIterations, VectorFloat priorProbabilities) => SimpleITK.MultiLabelSTAPLE(images, labelForUndecidedPixels, terminationUpdateThreshold, maximumNumberOfIterations, priorProbabilities);
   public static Image Multiply(this double constant, Image image2) => SimpleITK.Multiply(constant, image2);
   public static Image Multiply(this Image image1, double constant) => SimpleITK.Multiply(image1, constant);
   public static Image Multiply(this Image image1, Image image2) => SimpleITK.Multiply(image1, image2);
   public static Image N4BiasFieldCorrection(this Image image) => SimpleITK.N4BiasFieldCorrection(image);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold, maximumNumberOfIterations);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins, VectorUInt32 numberOfControlPoints, uint splineOrder, bool useMaskLabel, byte maskLabel) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins, numberOfControlPoints, splineOrder, useMaskLabel, maskLabel);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins, VectorUInt32 numberOfControlPoints, uint splineOrder, bool useMaskLabel) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins, numberOfControlPoints, splineOrder, useMaskLabel);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins, VectorUInt32 numberOfControlPoints, uint splineOrder) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins, numberOfControlPoints, splineOrder);
   public static Image N4BiasFieldCorrection(this Image image, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins, VectorUInt32 numberOfControlPoints) => SimpleITK.N4BiasFieldCorrection(image, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins, numberOfControlPoints);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage) => SimpleITK.N4BiasFieldCorrection(image, maskImage);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold, maximumNumberOfIterations);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins, VectorUInt32 numberOfControlPoints, uint splineOrder, bool useMaskLabel, byte maskLabel) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins, numberOfControlPoints, splineOrder, useMaskLabel, maskLabel);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins, VectorUInt32 numberOfControlPoints, uint splineOrder, bool useMaskLabel) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins, numberOfControlPoints, splineOrder, useMaskLabel);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins, VectorUInt32 numberOfControlPoints, uint splineOrder) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins, numberOfControlPoints, splineOrder);
   public static Image N4BiasFieldCorrection(this Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint numberOfHistogramBins, VectorUInt32 numberOfControlPoints) => SimpleITK.N4BiasFieldCorrection(image, maskImage, convergenceThreshold, maximumNumberOfIterations, biasFieldFullWidthAtHalfMaximum, wienerFilterNoise, numberOfHistogramBins, numberOfControlPoints);
   public static Image NaryAdd(this Image image1) => SimpleITK.NaryAdd(image1);
   public static Image NaryAdd(this Image image1, Image image2) => SimpleITK.NaryAdd(image1, image2);
   public static Image NaryAdd(this Image image1, Image image2, Image image3) => SimpleITK.NaryAdd(image1, image2, image3);
   public static Image NaryAdd(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.NaryAdd(image1, image2, image3, image4);
   public static Image NaryAdd(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.NaryAdd(image1, image2, image3, image4, image5);
   public static Image NaryAdd(this VectorOfImage images) => SimpleITK.NaryAdd(images);
   public static Image NaryMaximum(this Image image1) => SimpleITK.NaryMaximum(image1);
   public static Image NaryMaximum(this Image image1, Image image2) => SimpleITK.NaryMaximum(image1, image2);
   public static Image NaryMaximum(this Image image1, Image image2, Image image3) => SimpleITK.NaryMaximum(image1, image2, image3);
   public static Image NaryMaximum(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.NaryMaximum(image1, image2, image3, image4);
   public static Image NaryMaximum(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.NaryMaximum(image1, image2, image3, image4, image5);
   public static Image NaryMaximum(this VectorOfImage images) => SimpleITK.NaryMaximum(images);
   public static Image NeighborhoodConnected(this Image image1) => SimpleITK.NeighborhoodConnected(image1);
   public static Image NeighborhoodConnected(this Image image1, VectorUIntList seedList) => SimpleITK.NeighborhoodConnected(image1, seedList);
   public static Image NeighborhoodConnected(this Image image1, VectorUIntList seedList, double lower) => SimpleITK.NeighborhoodConnected(image1, seedList, lower);
   public static Image NeighborhoodConnected(this Image image1, VectorUIntList seedList, double lower, double upper) => SimpleITK.NeighborhoodConnected(image1, seedList, lower, upper);
   public static Image NeighborhoodConnected(this Image image1, VectorUIntList seedList, double lower, double upper, VectorUInt32 radius) => SimpleITK.NeighborhoodConnected(image1, seedList, lower, upper, radius);
   public static Image NeighborhoodConnected(this Image image1, VectorUIntList seedList, double lower, double upper, VectorUInt32 radius, double replaceValue) => SimpleITK.NeighborhoodConnected(image1, seedList, lower, upper, radius, replaceValue);
   public static Image Noise(this Image image1) => SimpleITK.Noise(image1);
   public static Image Noise(this Image image1, VectorUInt32 radius) => SimpleITK.Noise(image1, radius);
   public static Image Normalize(this Image image1) => SimpleITK.Normalize(image1);
   public static Image NormalizedCorrelation(this Image image, Image maskImage, Image templateImage) => SimpleITK.NormalizedCorrelation(image, maskImage, templateImage);
   public static Image NormalizeToConstant(this Image image1) => SimpleITK.NormalizeToConstant(image1);
   public static Image NormalizeToConstant(this Image image1, double constant) => SimpleITK.NormalizeToConstant(image1, constant);
   public static Image Not(this Image image1) => SimpleITK.Not(image1);
   public static Image NotEqual(this double constant, Image image2) => SimpleITK.NotEqual(constant, image2);
   public static Image NotEqual(this double constant, Image image2, byte backgroundValue) => SimpleITK.NotEqual(constant, image2, backgroundValue);
   public static Image NotEqual(this double constant, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.NotEqual(constant, image2, backgroundValue, foregroundValue);
   public static Image NotEqual(this Image image1, double constant) => SimpleITK.NotEqual(image1, constant);
   public static Image NotEqual(this Image image1, double constant, byte backgroundValue) => SimpleITK.NotEqual(image1, constant, backgroundValue);
   public static Image NotEqual(this Image image1, double constant, byte backgroundValue, byte foregroundValue) => SimpleITK.NotEqual(image1, constant, backgroundValue, foregroundValue);
   public static Image NotEqual(this Image image1, Image image2) => SimpleITK.NotEqual(image1, image2);
   public static Image NotEqual(this Image image1, Image image2, byte backgroundValue) => SimpleITK.NotEqual(image1, image2, backgroundValue);
   public static Image NotEqual(this Image image1, Image image2, byte backgroundValue, byte foregroundValue) => SimpleITK.NotEqual(image1, image2, backgroundValue, foregroundValue);
   public static Image ObjectnessMeasure(this Image image1) => SimpleITK.ObjectnessMeasure(image1);
   public static Image ObjectnessMeasure(this Image image1, double alpha) => SimpleITK.ObjectnessMeasure(image1, alpha);
   public static Image ObjectnessMeasure(this Image image1, double alpha, double beta) => SimpleITK.ObjectnessMeasure(image1, alpha, beta);
   public static Image ObjectnessMeasure(this Image image1, double alpha, double beta, double gamma) => SimpleITK.ObjectnessMeasure(image1, alpha, beta, gamma);
   public static Image ObjectnessMeasure(this Image image1, double alpha, double beta, double gamma, bool scaleObjectnessMeasure) => SimpleITK.ObjectnessMeasure(image1, alpha, beta, gamma, scaleObjectnessMeasure);
   public static Image ObjectnessMeasure(this Image image1, double alpha, double beta, double gamma, bool scaleObjectnessMeasure, uint objectDimension) => SimpleITK.ObjectnessMeasure(image1, alpha, beta, gamma, scaleObjectnessMeasure, objectDimension);
   public static Image ObjectnessMeasure(this Image image1, double alpha, double beta, double gamma, bool scaleObjectnessMeasure, uint objectDimension, bool brightObject) => SimpleITK.ObjectnessMeasure(image1, alpha, beta, gamma, scaleObjectnessMeasure, objectDimension, brightObject);
   public static Image OpeningByReconstruction(this Image image1) => SimpleITK.OpeningByReconstruction(image1);
   public static Image OpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.OpeningByReconstruction(image1, kernelRadius);
   public static Image OpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.OpeningByReconstruction(image1, kernelRadius, kernelType);
   public static Image OpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, bool fullyConnected) => SimpleITK.OpeningByReconstruction(image1, kernelRadius, kernelType, fullyConnected);
   public static Image OpeningByReconstruction(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, bool fullyConnected, bool preserveIntensities) => SimpleITK.OpeningByReconstruction(image1, kernelRadius, kernelType, fullyConnected, preserveIntensities);
   public static Image Or(this Image image1, Image image2) => SimpleITK.Or(image1, image2);
   public static Image Or(this Image image1, int constant) => SimpleITK.Or(image1, constant);
   public static Image Or(this int constant, Image image2) => SimpleITK.Or(constant, image2);
   public static Image OtsuMultipleThresholds(this Image image1) => SimpleITK.OtsuMultipleThresholds(image1);
   public static Image OtsuMultipleThresholds(this Image image1, byte numberOfThresholds) => SimpleITK.OtsuMultipleThresholds(image1, numberOfThresholds);
   public static Image OtsuMultipleThresholds(this Image image1, byte numberOfThresholds, byte labelOffset) => SimpleITK.OtsuMultipleThresholds(image1, numberOfThresholds, labelOffset);
   public static Image OtsuMultipleThresholds(this Image image1, byte numberOfThresholds, byte labelOffset, uint numberOfHistogramBins) => SimpleITK.OtsuMultipleThresholds(image1, numberOfThresholds, labelOffset, numberOfHistogramBins);
   public static Image OtsuMultipleThresholds(this Image image1, byte numberOfThresholds, byte labelOffset, uint numberOfHistogramBins, bool valleyEmphasis) => SimpleITK.OtsuMultipleThresholds(image1, numberOfThresholds, labelOffset, numberOfHistogramBins, valleyEmphasis);
   public static Image OtsuMultipleThresholds(this Image image1, byte numberOfThresholds, byte labelOffset, uint numberOfHistogramBins, bool valleyEmphasis, bool returnBinMidpoint) => SimpleITK.OtsuMultipleThresholds(image1, numberOfThresholds, labelOffset, numberOfHistogramBins, valleyEmphasis, returnBinMidpoint);
   public static Image OtsuThreshold(this Image image) => SimpleITK.OtsuThreshold(image);
   public static Image OtsuThreshold(this Image image, byte insideValue) => SimpleITK.OtsuThreshold(image, insideValue);
   public static Image OtsuThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.OtsuThreshold(image, insideValue, outsideValue);
   public static Image OtsuThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.OtsuThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image OtsuThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.OtsuThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image OtsuThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.OtsuThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image OtsuThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue, bool returnBinMidpoint) => SimpleITK.OtsuThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue, returnBinMidpoint);
   public static Image OtsuThreshold(this Image image, Image maskImage) => SimpleITK.OtsuThreshold(image, maskImage);
   public static Image OtsuThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.OtsuThreshold(image, maskImage, insideValue);
   public static Image OtsuThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.OtsuThreshold(image, maskImage, insideValue, outsideValue);
   public static Image OtsuThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.OtsuThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image OtsuThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.OtsuThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image OtsuThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.OtsuThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image OtsuThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue, bool returnBinMidpoint) => SimpleITK.OtsuThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue, returnBinMidpoint);
   public static Image Paste(this Image destinationImage, Image sourceImage) => SimpleITK.Paste(destinationImage, sourceImage);
   public static Image Paste(this Image destinationImage, Image sourceImage, VectorUInt32 sourceSize) => SimpleITK.Paste(destinationImage, sourceImage, sourceSize);
   public static Image Paste(this Image destinationImage, Image sourceImage, VectorUInt32 sourceSize, VectorInt32 sourceIndex) => SimpleITK.Paste(destinationImage, sourceImage, sourceSize, sourceIndex);
   public static Image Paste(this Image destinationImage, Image sourceImage, VectorUInt32 sourceSize, VectorInt32 sourceIndex, VectorInt32 destinationIndex) => SimpleITK.Paste(destinationImage, sourceImage, sourceSize, sourceIndex, destinationIndex);
   public static Image Paste(this Image destinationImage, Image sourceImage, VectorUInt32 sourceSize, VectorInt32 sourceIndex, VectorInt32 destinationIndex, VectorBool DestinationSkipAxes) => SimpleITK.Paste(destinationImage, sourceImage, sourceSize, sourceIndex, destinationIndex, DestinationSkipAxes);
   public static Image PatchBasedDenoising(this Image image1) => SimpleITK.PatchBasedDenoising(image1);
   public static Image PatchBasedDenoising(this Image image1, double kernelBandwidthSigma) => SimpleITK.PatchBasedDenoising(image1, kernelBandwidthSigma);
   public static Image PatchBasedDenoising(this Image image1, double kernelBandwidthSigma, uint patchRadius) => SimpleITK.PatchBasedDenoising(image1, kernelBandwidthSigma, patchRadius);
   public static Image PatchBasedDenoising(this Image image1, double kernelBandwidthSigma, uint patchRadius, uint numberOfIterations) => SimpleITK.PatchBasedDenoising(image1, kernelBandwidthSigma, patchRadius, numberOfIterations);
   public static Image PatchBasedDenoising(this Image image1, double kernelBandwidthSigma, uint patchRadius, uint numberOfIterations, uint numberOfSamplePatches) => SimpleITK.PatchBasedDenoising(image1, kernelBandwidthSigma, patchRadius, numberOfIterations, numberOfSamplePatches);
   public static Image PatchBasedDenoising(this Image image1, double kernelBandwidthSigma, uint patchRadius, uint numberOfIterations, uint numberOfSamplePatches, double sampleVariance) => SimpleITK.PatchBasedDenoising(image1, kernelBandwidthSigma, patchRadius, numberOfIterations, numberOfSamplePatches, sampleVariance);
   public static Image PatchBasedDenoising(this Image image1, PatchBasedDenoisingImageFilter.NoiseModelType noiseModel) => SimpleITK.PatchBasedDenoising(image1, noiseModel);
   public static Image PatchBasedDenoising(this Image image1, PatchBasedDenoisingImageFilter.NoiseModelType noiseModel, double kernelBandwidthSigma) => SimpleITK.PatchBasedDenoising(image1, noiseModel, kernelBandwidthSigma);
   public static Image PatchBasedDenoising(this Image image1, PatchBasedDenoisingImageFilter.NoiseModelType noiseModel, double kernelBandwidthSigma, uint patchRadius) => SimpleITK.PatchBasedDenoising(image1, noiseModel, kernelBandwidthSigma, patchRadius);
   public static Image PatchBasedDenoising(this Image image1, PatchBasedDenoisingImageFilter.NoiseModelType noiseModel, double kernelBandwidthSigma, uint patchRadius, uint numberOfIterations) => SimpleITK.PatchBasedDenoising(image1, noiseModel, kernelBandwidthSigma, patchRadius, numberOfIterations);
   public static Image PatchBasedDenoising(this Image image1, PatchBasedDenoisingImageFilter.NoiseModelType noiseModel, double kernelBandwidthSigma, uint patchRadius, uint numberOfIterations, uint numberOfSamplePatches) => SimpleITK.PatchBasedDenoising(image1, noiseModel, kernelBandwidthSigma, patchRadius, numberOfIterations, numberOfSamplePatches);
   public static Image PatchBasedDenoising(this Image image1, PatchBasedDenoisingImageFilter.NoiseModelType noiseModel, double kernelBandwidthSigma, uint patchRadius, uint numberOfIterations, uint numberOfSamplePatches, double sampleVariance) => SimpleITK.PatchBasedDenoising(image1, noiseModel, kernelBandwidthSigma, patchRadius, numberOfIterations, numberOfSamplePatches, sampleVariance);
   public static Image PatchBasedDenoising(this Image image1, PatchBasedDenoisingImageFilter.NoiseModelType noiseModel, double kernelBandwidthSigma, uint patchRadius, uint numberOfIterations, uint numberOfSamplePatches, double sampleVariance, double noiseSigma, double noiseModelFidelityWeight) => SimpleITK.PatchBasedDenoising(image1, noiseModel, kernelBandwidthSigma, patchRadius, numberOfIterations, numberOfSamplePatches, sampleVariance, noiseSigma, noiseModelFidelityWeight);
   public static Image PatchBasedDenoising(this Image image1, PatchBasedDenoisingImageFilter.NoiseModelType noiseModel, double kernelBandwidthSigma, uint patchRadius, uint numberOfIterations, uint numberOfSamplePatches, double sampleVariance, double noiseSigma) => SimpleITK.PatchBasedDenoising(image1, noiseModel, kernelBandwidthSigma, patchRadius, numberOfIterations, numberOfSamplePatches, sampleVariance, noiseSigma);
   public static Image PermuteAxes(this Image image1) => SimpleITK.PermuteAxes(image1);
   public static Image PermuteAxes(this Image image1, VectorUInt32 order) => SimpleITK.PermuteAxes(image1, order);
   public static Image Pow(this double constant, Image image2) => SimpleITK.Pow(constant, image2);
   public static Image Pow(this Image image1, double constant) => SimpleITK.Pow(image1, constant);
   public static Image Pow(this Image image1, Image image2) => SimpleITK.Pow(image1, image2);
   public static Image ProjectedLandweberDeconvolution(this Image image1, Image image2) => SimpleITK.ProjectedLandweberDeconvolution(image1, image2);
   public static Image ProjectedLandweberDeconvolution(this Image image1, Image image2, double alpha) => SimpleITK.ProjectedLandweberDeconvolution(image1, image2, alpha);
   public static Image ProjectedLandweberDeconvolution(this Image image1, Image image2, double alpha, int numberOfIterations) => SimpleITK.ProjectedLandweberDeconvolution(image1, image2, alpha, numberOfIterations);
   public static Image ProjectedLandweberDeconvolution(this Image image1, Image image2, double alpha, int numberOfIterations, bool normalize) => SimpleITK.ProjectedLandweberDeconvolution(image1, image2, alpha, numberOfIterations, normalize);
   public static Image ProjectedLandweberDeconvolution(this Image image1, Image image2, double alpha, int numberOfIterations, bool normalize, ProjectedLandweberDeconvolutionImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.ProjectedLandweberDeconvolution(image1, image2, alpha, numberOfIterations, normalize, boundaryCondition);
   public static Image ProjectedLandweberDeconvolution(this Image image1, Image image2, double alpha, int numberOfIterations, bool normalize, ProjectedLandweberDeconvolutionImageFilter.BoundaryConditionType boundaryCondition, ProjectedLandweberDeconvolutionImageFilter.OutputRegionModeType outputRegionMode) => SimpleITK.ProjectedLandweberDeconvolution(image1, image2, alpha, numberOfIterations, normalize, boundaryCondition, outputRegionMode);
   public static Image Rank(this Image image1) => SimpleITK.Rank(image1);
   public static Image Rank(this Image image1, double rank) => SimpleITK.Rank(image1, rank);
   public static Image Rank(this Image image1, double rank, VectorUInt32 radius) => SimpleITK.Rank(image1, rank, radius);
   public static Image Rank(this Image image1, double rank, VectorUInt32 radius, KernelEnum kernelType) => SimpleITK.Rank(image1, rank, radius, kernelType);
   public static Image RealAndImaginaryToComplex(this Image image1, Image image2) => SimpleITK.RealAndImaginaryToComplex(image1, image2);
   public static Image RealToHalfHermitianForwardFFT(this Image image1) => SimpleITK.RealToHalfHermitianForwardFFT(image1);
   public static Image ReconstructionByDilation(this Image markerImage, Image maskImage) => SimpleITK.ReconstructionByDilation(markerImage, maskImage);
   public static Image ReconstructionByDilation(this Image markerImage, Image maskImage, bool fullyConnected) => SimpleITK.ReconstructionByDilation(markerImage, maskImage, fullyConnected);
   public static Image ReconstructionByDilation(this Image markerImage, Image maskImage, bool fullyConnected, bool useInternalCopy) => SimpleITK.ReconstructionByDilation(markerImage, maskImage, fullyConnected, useInternalCopy);
   public static Image ReconstructionByErosion(this Image markerImage, Image maskImage) => SimpleITK.ReconstructionByErosion(markerImage, maskImage);
   public static Image ReconstructionByErosion(this Image markerImage, Image maskImage, bool fullyConnected) => SimpleITK.ReconstructionByErosion(markerImage, maskImage, fullyConnected);
   public static Image ReconstructionByErosion(this Image markerImage, Image maskImage, bool fullyConnected, bool useInternalCopy) => SimpleITK.ReconstructionByErosion(markerImage, maskImage, fullyConnected, useInternalCopy);
   public static Image RecursiveGaussian(this Image image1) => SimpleITK.RecursiveGaussian(image1);
   public static Image RecursiveGaussian(this Image image1, double sigma) => SimpleITK.RecursiveGaussian(image1, sigma);
   public static Image RecursiveGaussian(this Image image1, double sigma, bool normalizeAcrossScale) => SimpleITK.RecursiveGaussian(image1, sigma, normalizeAcrossScale);
   public static Image RecursiveGaussian(this Image image1, double sigma, bool normalizeAcrossScale, RecursiveGaussianImageFilter.OrderType order) => SimpleITK.RecursiveGaussian(image1, sigma, normalizeAcrossScale, order);
   public static Image RecursiveGaussian(this Image image1, double sigma, bool normalizeAcrossScale, RecursiveGaussianImageFilter.OrderType order, uint direction) => SimpleITK.RecursiveGaussian(image1, sigma, normalizeAcrossScale, order, direction);
   public static Image RegionalMaxima(this Image image1) => SimpleITK.RegionalMaxima(image1);
   public static Image RegionalMaxima(this Image image1, double backgroundValue) => SimpleITK.RegionalMaxima(image1, backgroundValue);
   public static Image RegionalMaxima(this Image image1, double backgroundValue, double foregroundValue) => SimpleITK.RegionalMaxima(image1, backgroundValue, foregroundValue);
   public static Image RegionalMaxima(this Image image1, double backgroundValue, double foregroundValue, bool fullyConnected) => SimpleITK.RegionalMaxima(image1, backgroundValue, foregroundValue, fullyConnected);
   public static Image RegionalMaxima(this Image image1, double backgroundValue, double foregroundValue, bool fullyConnected, bool flatIsMaxima) => SimpleITK.RegionalMaxima(image1, backgroundValue, foregroundValue, fullyConnected, flatIsMaxima);
   public static Image RegionalMinima(this Image image1) => SimpleITK.RegionalMinima(image1);
   public static Image RegionalMinima(this Image image1, double backgroundValue) => SimpleITK.RegionalMinima(image1, backgroundValue);
   public static Image RegionalMinima(this Image image1, double backgroundValue, double foregroundValue) => SimpleITK.RegionalMinima(image1, backgroundValue, foregroundValue);
   public static Image RegionalMinima(this Image image1, double backgroundValue, double foregroundValue, bool fullyConnected) => SimpleITK.RegionalMinima(image1, backgroundValue, foregroundValue, fullyConnected);
   public static Image RegionalMinima(this Image image1, double backgroundValue, double foregroundValue, bool fullyConnected, bool flatIsMinima) => SimpleITK.RegionalMinima(image1, backgroundValue, foregroundValue, fullyConnected, flatIsMinima);
   public static Image RegionOfInterest(this Image image1) => SimpleITK.RegionOfInterest(image1);
   public static Image RegionOfInterest(this Image image1, VectorUInt32 size) => SimpleITK.RegionOfInterest(image1, size);
   public static Image RegionOfInterest(this Image image1, VectorUInt32 size, VectorInt32 index) => SimpleITK.RegionOfInterest(image1, size, index);
   public static Image RelabelComponent(this Image image1) => SimpleITK.RelabelComponent(image1);
   public static Image RelabelComponent(this Image image1, ulong minimumObjectSize) => SimpleITK.RelabelComponent(image1, minimumObjectSize);
   public static Image RelabelComponent(this Image image1, ulong minimumObjectSize, bool sortByObjectSize) => SimpleITK.RelabelComponent(image1, minimumObjectSize, sortByObjectSize);
   public static Image RelabelLabelMap(this Image image1) => SimpleITK.RelabelLabelMap(image1);
   public static Image RelabelLabelMap(this Image image1, bool reverseOrdering) => SimpleITK.RelabelLabelMap(image1, reverseOrdering);
   public static Image RenyiEntropyThreshold(this Image image) => SimpleITK.RenyiEntropyThreshold(image);
   public static Image RenyiEntropyThreshold(this Image image, byte insideValue) => SimpleITK.RenyiEntropyThreshold(image, insideValue);
   public static Image RenyiEntropyThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.RenyiEntropyThreshold(image, insideValue, outsideValue);
   public static Image RenyiEntropyThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.RenyiEntropyThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image RenyiEntropyThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.RenyiEntropyThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image RenyiEntropyThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.RenyiEntropyThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image RenyiEntropyThreshold(this Image image, Image maskImage) => SimpleITK.RenyiEntropyThreshold(image, maskImage);
   public static Image RenyiEntropyThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.RenyiEntropyThreshold(image, maskImage, insideValue);
   public static Image RenyiEntropyThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.RenyiEntropyThreshold(image, maskImage, insideValue, outsideValue);
   public static Image RenyiEntropyThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.RenyiEntropyThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image RenyiEntropyThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.RenyiEntropyThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image RenyiEntropyThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.RenyiEntropyThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image Resample(this Image image1) => SimpleITK.Resample(image1);
   public static Image Resample(this Image image1, Image referenceImage) => SimpleITK.Resample(image1, referenceImage);
   public static Image Resample(this Image image1, Image referenceImage, Transform transform) => SimpleITK.Resample(image1, referenceImage, transform);
   public static Image Resample(this Image image1, Image referenceImage, Transform transform, InterpolatorEnum interpolator) => SimpleITK.Resample(image1, referenceImage, transform, interpolator);
   public static Image Resample(this Image image1, Image referenceImage, Transform transform, InterpolatorEnum interpolator, double defaultPixelValue) => SimpleITK.Resample(image1, referenceImage, transform, interpolator, defaultPixelValue);
   public static Image Resample(this Image image1, Image referenceImage, Transform transform, InterpolatorEnum interpolator, double defaultPixelValue, PixelIDValueEnum outputPixelType) => SimpleITK.Resample(image1, referenceImage, transform, interpolator, defaultPixelValue, outputPixelType);
   public static Image Resample(this Image image1, Image referenceImage, Transform transform, InterpolatorEnum interpolator, double defaultPixelValue, PixelIDValueEnum outputPixelType, bool useNearestNeighborExtrapolator) => SimpleITK.Resample(image1, referenceImage, transform, interpolator, defaultPixelValue, outputPixelType, useNearestNeighborExtrapolator);
   public static Image Resample(this Image image1, Transform transform) => SimpleITK.Resample(image1, transform);
   public static Image Resample(this Image image1, Transform transform, InterpolatorEnum interpolator) => SimpleITK.Resample(image1, transform, interpolator);
   public static Image Resample(this Image image1, Transform transform, InterpolatorEnum interpolator, double defaultPixelValue) => SimpleITK.Resample(image1, transform, interpolator, defaultPixelValue);
   public static Image Resample(this Image image1, Transform transform, InterpolatorEnum interpolator, double defaultPixelValue, PixelIDValueEnum outputPixelType) => SimpleITK.Resample(image1, transform, interpolator, defaultPixelValue, outputPixelType);
   public static Image Resample(this Image image1, Transform transform, InterpolatorEnum interpolator, double defaultPixelValue, PixelIDValueEnum outputPixelType, bool useNearestNeighborExtrapolator) => SimpleITK.Resample(image1, transform, interpolator, defaultPixelValue, outputPixelType, useNearestNeighborExtrapolator);
   public static Image Resample(this Image image1, VectorUInt32 size) => SimpleITK.Resample(image1, size);
   public static Image Resample(this Image image1, VectorUInt32 size, Transform transform) => SimpleITK.Resample(image1, size, transform);
   public static Image Resample(this Image image1, VectorUInt32 size, Transform transform, InterpolatorEnum interpolator) => SimpleITK.Resample(image1, size, transform, interpolator);
   public static Image Resample(this Image image1, VectorUInt32 size, Transform transform, InterpolatorEnum interpolator, VectorDouble outputOrigin) => SimpleITK.Resample(image1, size, transform, interpolator, outputOrigin);
   public static Image Resample(this Image image1, VectorUInt32 size, Transform transform, InterpolatorEnum interpolator, VectorDouble outputOrigin, VectorDouble outputSpacing) => SimpleITK.Resample(image1, size, transform, interpolator, outputOrigin, outputSpacing);
   public static Image Resample(this Image image1, VectorUInt32 size, Transform transform, InterpolatorEnum interpolator, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection) => SimpleITK.Resample(image1, size, transform, interpolator, outputOrigin, outputSpacing, outputDirection);
   public static Image Resample(this Image image1, VectorUInt32 size, Transform transform, InterpolatorEnum interpolator, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection, double defaultPixelValue) => SimpleITK.Resample(image1, size, transform, interpolator, outputOrigin, outputSpacing, outputDirection, defaultPixelValue);
   public static Image Resample(this Image image1, VectorUInt32 size, Transform transform, InterpolatorEnum interpolator, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection, double defaultPixelValue, PixelIDValueEnum outputPixelType, bool useNearestNeighborExtrapolator) => SimpleITK.Resample(image1, size, transform, interpolator, outputOrigin, outputSpacing, outputDirection, defaultPixelValue, outputPixelType, useNearestNeighborExtrapolator);
   public static Image Resample(this Image image1, VectorUInt32 size, Transform transform, InterpolatorEnum interpolator, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection, double defaultPixelValue, PixelIDValueEnum outputPixelType) => SimpleITK.Resample(image1, size, transform, interpolator, outputOrigin, outputSpacing, outputDirection, defaultPixelValue, outputPixelType);
   public static Image RescaleIntensity(this Image image1) => SimpleITK.RescaleIntensity(image1);
   public static Image RescaleIntensity(this Image image1, double outputMinimum) => SimpleITK.RescaleIntensity(image1, outputMinimum);
   public static Image RescaleIntensity(this Image image1, double outputMinimum, double outputMaximum) => SimpleITK.RescaleIntensity(image1, outputMinimum, outputMaximum);
   public static Image RichardsonLucyDeconvolution(this Image image1, Image image2) => SimpleITK.RichardsonLucyDeconvolution(image1, image2);
   public static Image RichardsonLucyDeconvolution(this Image image1, Image image2, int numberOfIterations) => SimpleITK.RichardsonLucyDeconvolution(image1, image2, numberOfIterations);
   public static Image RichardsonLucyDeconvolution(this Image image1, Image image2, int numberOfIterations, bool normalize) => SimpleITK.RichardsonLucyDeconvolution(image1, image2, numberOfIterations, normalize);
   public static Image RichardsonLucyDeconvolution(this Image image1, Image image2, int numberOfIterations, bool normalize, RichardsonLucyDeconvolutionImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.RichardsonLucyDeconvolution(image1, image2, numberOfIterations, normalize, boundaryCondition);
   public static Image RichardsonLucyDeconvolution(this Image image1, Image image2, int numberOfIterations, bool normalize, RichardsonLucyDeconvolutionImageFilter.BoundaryConditionType boundaryCondition, RichardsonLucyDeconvolutionImageFilter.OutputRegionModeType outputRegionMode) => SimpleITK.RichardsonLucyDeconvolution(image1, image2, numberOfIterations, normalize, boundaryCondition, outputRegionMode);
   public static Image Round(this Image image1) => SimpleITK.Round(image1);
   public static Image SaltAndPepperNoise(this Image image1) => SimpleITK.SaltAndPepperNoise(image1);
   public static Image SaltAndPepperNoise(this Image image1, double probability) => SimpleITK.SaltAndPepperNoise(image1, probability);
   public static Image SaltAndPepperNoise(this Image image1, double probability, uint seed) => SimpleITK.SaltAndPepperNoise(image1, probability, seed);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2, double epsilon) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2, epsilon);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2, double epsilon, double curvatureWeight) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2, epsilon, curvatureWeight);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2, double epsilon, double curvatureWeight, double areaWeight) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2, epsilon, curvatureWeight, areaWeight);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2, double epsilon, double curvatureWeight, double areaWeight, double reinitializationSmoothingWeight, double volume, double volumeMatchingWeight, ScalarChanAndVeseDenseLevelSetImageFilter.HeavisideStepFunctionType heavisideStepFunction, bool useImageSpacing) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2, epsilon, curvatureWeight, areaWeight, reinitializationSmoothingWeight, volume, volumeMatchingWeight, heavisideStepFunction);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2, double epsilon, double curvatureWeight, double areaWeight, double reinitializationSmoothingWeight, double volume, double volumeMatchingWeight, ScalarChanAndVeseDenseLevelSetImageFilter.HeavisideStepFunctionType heavisideStepFunction) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2, epsilon, curvatureWeight, areaWeight, reinitializationSmoothingWeight, volume, volumeMatchingWeight, heavisideStepFunction);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2, double epsilon, double curvatureWeight, double areaWeight, double reinitializationSmoothingWeight, double volume, double volumeMatchingWeight) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2, epsilon, curvatureWeight, areaWeight, reinitializationSmoothingWeight, volume, volumeMatchingWeight);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2, double epsilon, double curvatureWeight, double areaWeight, double reinitializationSmoothingWeight, double volume) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2, epsilon, curvatureWeight, areaWeight, reinitializationSmoothingWeight, volume);
   public static Image ScalarChanAndVeseDenseLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, uint numberOfIterations, double lambda1, double lambda2, double epsilon, double curvatureWeight, double areaWeight, double reinitializationSmoothingWeight) => SimpleITK.ScalarChanAndVeseDenseLevelSet(initialImage, featureImage, maximumRMSError, numberOfIterations, lambda1, lambda2, epsilon, curvatureWeight, areaWeight, reinitializationSmoothingWeight);
   public static Image ScalarConnectedComponent(this Image image) => SimpleITK.ScalarConnectedComponent(image);
   public static Image ScalarConnectedComponent(this Image image, double distanceThreshold) => SimpleITK.ScalarConnectedComponent(image, distanceThreshold);
   public static Image ScalarConnectedComponent(this Image image, double distanceThreshold, bool fullyConnected) => SimpleITK.ScalarConnectedComponent(image, distanceThreshold, fullyConnected);
   public static Image ScalarConnectedComponent(this Image image, Image maskImage) => SimpleITK.ScalarConnectedComponent(image, maskImage);
   public static Image ScalarConnectedComponent(this Image image, Image maskImage, double distanceThreshold) => SimpleITK.ScalarConnectedComponent(image, maskImage, distanceThreshold);
   public static Image ScalarConnectedComponent(this Image image, Image maskImage, double distanceThreshold, bool fullyConnected) => SimpleITK.ScalarConnectedComponent(image, maskImage, distanceThreshold, fullyConnected);
   public static Image ScalarImageKmeans(this Image image1) => SimpleITK.ScalarImageKmeans(image1);
   public static Image ScalarImageKmeans(this Image image1, VectorDouble classWithInitialMean) => SimpleITK.ScalarImageKmeans(image1, classWithInitialMean);
   public static Image ScalarImageKmeans(this Image image1, VectorDouble classWithInitialMean, bool useNonContiguousLabels) => SimpleITK.ScalarImageKmeans(image1, classWithInitialMean, useNonContiguousLabels);
   public static Image ScalarToRGBColormap(this Image image1) => SimpleITK.ScalarToRGBColormap(image1);
   public static Image ScalarToRGBColormap(this Image image1, ScalarToRGBColormapImageFilter.ColormapType colormap) => SimpleITK.ScalarToRGBColormap(image1, colormap);
   public static Image ScalarToRGBColormap(this Image image1, ScalarToRGBColormapImageFilter.ColormapType colormap, bool useInputImageExtremaForScaling) => SimpleITK.ScalarToRGBColormap(image1, colormap, useInputImageExtremaForScaling);
   public static Image ShanbhagThreshold(this Image image) => SimpleITK.ShanbhagThreshold(image);
   public static Image ShanbhagThreshold(this Image image, byte insideValue) => SimpleITK.ShanbhagThreshold(image, insideValue);
   public static Image ShanbhagThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.ShanbhagThreshold(image, insideValue, outsideValue);
   public static Image ShanbhagThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.ShanbhagThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image ShanbhagThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.ShanbhagThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image ShanbhagThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.ShanbhagThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image ShanbhagThreshold(this Image image, Image maskImage) => SimpleITK.ShanbhagThreshold(image, maskImage);
   public static Image ShanbhagThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.ShanbhagThreshold(image, maskImage, insideValue);
   public static Image ShanbhagThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.ShanbhagThreshold(image, maskImage, insideValue, outsideValue);
   public static Image ShanbhagThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.ShanbhagThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image ShanbhagThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.ShanbhagThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image ShanbhagThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.ShanbhagThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image ShapeDetectionLevelSet(this Image initialImage, Image featureImage) => SimpleITK.ShapeDetectionLevelSet(initialImage, featureImage);
   public static Image ShapeDetectionLevelSet(this Image initialImage, Image featureImage, double maximumRMSError) => SimpleITK.ShapeDetectionLevelSet(initialImage, featureImage, maximumRMSError);
   public static Image ShapeDetectionLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, double propagationScaling) => SimpleITK.ShapeDetectionLevelSet(initialImage, featureImage, maximumRMSError, propagationScaling);
   public static Image ShapeDetectionLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, double propagationScaling, double curvatureScaling) => SimpleITK.ShapeDetectionLevelSet(initialImage, featureImage, maximumRMSError, propagationScaling, curvatureScaling);
   public static Image ShapeDetectionLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, double propagationScaling, double curvatureScaling, uint numberOfIterations) => SimpleITK.ShapeDetectionLevelSet(initialImage, featureImage, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations);
   public static Image ShapeDetectionLevelSet(this Image initialImage, Image featureImage, double maximumRMSError, double propagationScaling, double curvatureScaling, uint numberOfIterations, bool reverseExpansionDirection) => SimpleITK.ShapeDetectionLevelSet(initialImage, featureImage, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations, reverseExpansionDirection);
   public static Image ShiftScale(this Image image1) => SimpleITK.ShiftScale(image1);
   public static Image ShiftScale(this Image image1, double shift) => SimpleITK.ShiftScale(image1, shift);
   public static Image ShiftScale(this Image image1, double shift, double scale) => SimpleITK.ShiftScale(image1, shift, scale);
   public static Image ShiftScale(this Image image1, double shift, double scale, PixelIDValueEnum outputPixelType) => SimpleITK.ShiftScale(image1, shift, scale, outputPixelType);
   public static Image ShotNoise(this Image image1) => SimpleITK.ShotNoise(image1);
   public static Image ShotNoise(this Image image1, double scale) => SimpleITK.ShotNoise(image1, scale);
   public static Image ShotNoise(this Image image1, double scale, uint seed) => SimpleITK.ShotNoise(image1, scale, seed);
   public static Image Shrink(this Image image1) => SimpleITK.Shrink(image1);
   public static Image Shrink(this Image image1, VectorUInt32 shrinkFactors) => SimpleITK.Shrink(image1, shrinkFactors);
   public static Image Sigmoid(this Image image1) => SimpleITK.Sigmoid(image1);
   public static Image Sigmoid(this Image image1, double alpha) => SimpleITK.Sigmoid(image1, alpha);
   public static Image Sigmoid(this Image image1, double alpha, double beta) => SimpleITK.Sigmoid(image1, alpha, beta);
   public static Image Sigmoid(this Image image1, double alpha, double beta, double outputMaximum) => SimpleITK.Sigmoid(image1, alpha, beta, outputMaximum);
   public static Image Sigmoid(this Image image1, double alpha, double beta, double outputMaximum, double outputMinimum) => SimpleITK.Sigmoid(image1, alpha, beta, outputMaximum, outputMinimum);
   public static Image SignedDanielssonDistanceMap(this Image image1) => SimpleITK.SignedDanielssonDistanceMap(image1);
   public static Image SignedDanielssonDistanceMap(this Image image1, bool insideIsPositive) => SimpleITK.SignedDanielssonDistanceMap(image1, insideIsPositive);
   public static Image SignedDanielssonDistanceMap(this Image image1, bool insideIsPositive, bool squaredDistance) => SimpleITK.SignedDanielssonDistanceMap(image1, insideIsPositive, squaredDistance);
   public static Image SignedDanielssonDistanceMap(this Image image1, bool insideIsPositive, bool squaredDistance, bool useImageSpacing) => SimpleITK.SignedDanielssonDistanceMap(image1, insideIsPositive, squaredDistance, useImageSpacing);
   public static Image SignedMaurerDistanceMap(this Image image1) => SimpleITK.SignedMaurerDistanceMap(image1);
   public static Image SignedMaurerDistanceMap(this Image image1, bool insideIsPositive) => SimpleITK.SignedMaurerDistanceMap(image1, insideIsPositive);
   public static Image SignedMaurerDistanceMap(this Image image1, bool insideIsPositive, bool squaredDistance) => SimpleITK.SignedMaurerDistanceMap(image1, insideIsPositive, squaredDistance);
   public static Image SignedMaurerDistanceMap(this Image image1, bool insideIsPositive, bool squaredDistance, bool useImageSpacing) => SimpleITK.SignedMaurerDistanceMap(image1, insideIsPositive, squaredDistance, useImageSpacing);
   public static Image SignedMaurerDistanceMap(this Image image1, bool insideIsPositive, bool squaredDistance, bool useImageSpacing, double backgroundValue) => SimpleITK.SignedMaurerDistanceMap(image1, insideIsPositive, squaredDistance, useImageSpacing, backgroundValue);
   public static Image SimpleContourExtractor(this Image image1) => SimpleITK.SimpleContourExtractor(image1);
   public static Image SimpleContourExtractor(this Image image1, double inputForegroundValue) => SimpleITK.SimpleContourExtractor(image1, inputForegroundValue);
   public static Image SimpleContourExtractor(this Image image1, double inputForegroundValue, double inputBackgroundValue) => SimpleITK.SimpleContourExtractor(image1, inputForegroundValue, inputBackgroundValue);
   public static Image SimpleContourExtractor(this Image image1, double inputForegroundValue, double inputBackgroundValue, VectorUInt32 radius) => SimpleITK.SimpleContourExtractor(image1, inputForegroundValue, inputBackgroundValue, radius);
   public static Image SimpleContourExtractor(this Image image1, double inputForegroundValue, double inputBackgroundValue, VectorUInt32 radius, double outputForegroundValue) => SimpleITK.SimpleContourExtractor(image1, inputForegroundValue, inputBackgroundValue, radius, outputForegroundValue);
   public static Image SimpleContourExtractor(this Image image1, double inputForegroundValue, double inputBackgroundValue, VectorUInt32 radius, double outputForegroundValue, double outputBackgroundValue) => SimpleITK.SimpleContourExtractor(image1, inputForegroundValue, inputBackgroundValue, radius, outputForegroundValue, outputBackgroundValue);
   public static Image Sin(this Image image1) => SimpleITK.Sin(image1);
   public static Image SLIC(this Image image1) => SimpleITK.SLIC(image1);
   public static Image SLIC(this Image image1, VectorUInt32 superGridSize) => SimpleITK.SLIC(image1, superGridSize);
   public static Image SLIC(this Image image1, VectorUInt32 superGridSize, double spatialProximityWeight) => SimpleITK.SLIC(image1, superGridSize, spatialProximityWeight);
   public static Image SLIC(this Image image1, VectorUInt32 superGridSize, double spatialProximityWeight, uint maximumNumberOfIterations) => SimpleITK.SLIC(image1, superGridSize, spatialProximityWeight, maximumNumberOfIterations);
   public static Image SLIC(this Image image1, VectorUInt32 superGridSize, double spatialProximityWeight, uint maximumNumberOfIterations, bool enforceConnectivity) => SimpleITK.SLIC(image1, superGridSize, spatialProximityWeight, maximumNumberOfIterations, enforceConnectivity);
   public static Image SLIC(this Image image1, VectorUInt32 superGridSize, double spatialProximityWeight, uint maximumNumberOfIterations, bool enforceConnectivity, bool initializationPerturbation) => SimpleITK.SLIC(image1, superGridSize, spatialProximityWeight, maximumNumberOfIterations, enforceConnectivity, initializationPerturbation);
   public static Image Slice(this Image image1) => SimpleITK.Slice(image1);
   public static Image Slice(this Image image1, VectorInt32 start) => SimpleITK.Slice(image1, start);
   public static Image Slice(this Image image1, VectorInt32 start, VectorInt32 stop) => SimpleITK.Slice(image1, start, stop);
   public static Image Slice(this Image image1, VectorInt32 start, VectorInt32 stop, VectorInt32 step) => SimpleITK.Slice(image1, start, stop, step);
   public static Image SmoothingRecursiveGaussian(this Image image1) => SimpleITK.SmoothingRecursiveGaussian(image1);
   public static Image SmoothingRecursiveGaussian(this Image image1, double sigma) => SimpleITK.SmoothingRecursiveGaussian(image1, sigma);
   public static Image SmoothingRecursiveGaussian(this Image image1, double sigma, bool normalizeAcrossScale) => SimpleITK.SmoothingRecursiveGaussian(image1, sigma, normalizeAcrossScale);
   public static Image SmoothingRecursiveGaussian(this Image image1, VectorDouble sigma) => SimpleITK.SmoothingRecursiveGaussian(image1, sigma);
   public static Image SmoothingRecursiveGaussian(this Image image1, VectorDouble sigma, bool normalizeAcrossScale) => SimpleITK.SmoothingRecursiveGaussian(image1, sigma, normalizeAcrossScale);
   public static Image SobelEdgeDetection(this Image image1) => SimpleITK.SobelEdgeDetection(image1);
   public static Image SpeckleNoise(this Image image1) => SimpleITK.SpeckleNoise(image1);
   public static Image SpeckleNoise(this Image image1, double standardDeviation) => SimpleITK.SpeckleNoise(image1, standardDeviation);
   public static Image SpeckleNoise(this Image image1, double standardDeviation, uint seed) => SimpleITK.SpeckleNoise(image1, standardDeviation, seed);
   public static Image Sqrt(this Image image1) => SimpleITK.Sqrt(image1);
   public static Image Square(this Image image1) => SimpleITK.Square(image1);
   public static Image SquaredDifference(this double constant, Image image2) => SimpleITK.SquaredDifference(constant, image2);
   public static Image SquaredDifference(this Image image1, double constant) => SimpleITK.SquaredDifference(image1, constant);
   public static Image SquaredDifference(this Image image1, Image image2) => SimpleITK.SquaredDifference(image1, image2);
   public static Image StandardDeviationProjection(this Image image1) => SimpleITK.StandardDeviationProjection(image1);
   public static Image StandardDeviationProjection(this Image image1, uint projectionDimension) => SimpleITK.StandardDeviationProjection(image1, projectionDimension);
   public static Image STAPLE(this Image image1) => SimpleITK.STAPLE(image1);
   public static Image STAPLE(this Image image1, double confidenceWeight) => SimpleITK.STAPLE(image1, confidenceWeight);
   public static Image STAPLE(this Image image1, double confidenceWeight, double foregroundValue) => SimpleITK.STAPLE(image1, confidenceWeight, foregroundValue);
   public static Image STAPLE(this Image image1, double confidenceWeight, double foregroundValue, uint maximumIterations) => SimpleITK.STAPLE(image1, confidenceWeight, foregroundValue, maximumIterations);
   public static Image STAPLE(this Image image1, Image image2) => SimpleITK.STAPLE(image1, image2);
   public static Image STAPLE(this Image image1, Image image2, double confidenceWeight) => SimpleITK.STAPLE(image1, image2, confidenceWeight);
   public static Image STAPLE(this Image image1, Image image2, double confidenceWeight, double foregroundValue) => SimpleITK.STAPLE(image1, image2, confidenceWeight, foregroundValue);
   public static Image STAPLE(this Image image1, Image image2, double confidenceWeight, double foregroundValue, uint maximumIterations) => SimpleITK.STAPLE(image1, image2, confidenceWeight, foregroundValue, maximumIterations);
   public static Image STAPLE(this Image image1, Image image2, Image image3) => SimpleITK.STAPLE(image1, image2, image3);
   public static Image STAPLE(this Image image1, Image image2, Image image3, double confidenceWeight) => SimpleITK.STAPLE(image1, image2, image3, confidenceWeight);
   public static Image STAPLE(this Image image1, Image image2, Image image3, double confidenceWeight, double foregroundValue) => SimpleITK.STAPLE(image1, image2, image3, confidenceWeight, foregroundValue);
   public static Image STAPLE(this Image image1, Image image2, Image image3, double confidenceWeight, double foregroundValue, uint maximumIterations) => SimpleITK.STAPLE(image1, image2, image3, confidenceWeight, foregroundValue, maximumIterations);
   public static Image STAPLE(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.STAPLE(image1, image2, image3, image4);
   public static Image STAPLE(this Image image1, Image image2, Image image3, Image image4, double confidenceWeight) => SimpleITK.STAPLE(image1, image2, image3, image4, confidenceWeight);
   public static Image STAPLE(this Image image1, Image image2, Image image3, Image image4, double confidenceWeight, double foregroundValue) => SimpleITK.STAPLE(image1, image2, image3, image4, confidenceWeight, foregroundValue);
   public static Image STAPLE(this Image image1, Image image2, Image image3, Image image4, double confidenceWeight, double foregroundValue, uint maximumIterations) => SimpleITK.STAPLE(image1, image2, image3, image4, confidenceWeight, foregroundValue, maximumIterations);
   public static Image STAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.STAPLE(image1, image2, image3, image4, image5);
   public static Image STAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5, double confidenceWeight) => SimpleITK.STAPLE(image1, image2, image3, image4, image5, confidenceWeight);
   public static Image STAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5, double confidenceWeight, double foregroundValue) => SimpleITK.STAPLE(image1, image2, image3, image4, image5, confidenceWeight, foregroundValue);
   public static Image STAPLE(this Image image1, Image image2, Image image3, Image image4, Image image5, double confidenceWeight, double foregroundValue, uint maximumIterations) => SimpleITK.STAPLE(image1, image2, image3, image4, image5, confidenceWeight, foregroundValue, maximumIterations);
   public static Image STAPLE(this VectorOfImage images) => SimpleITK.STAPLE(images);
   public static Image STAPLE(this VectorOfImage images, double confidenceWeight) => SimpleITK.STAPLE(images, confidenceWeight);
   public static Image STAPLE(this VectorOfImage images, double confidenceWeight, double foregroundValue) => SimpleITK.STAPLE(images, confidenceWeight, foregroundValue);
   public static Image STAPLE(this VectorOfImage images, double confidenceWeight, double foregroundValue, uint maximumIterations) => SimpleITK.STAPLE(images, confidenceWeight, foregroundValue, maximumIterations);
   public static Image StochasticFractalDimension(this Image image) => SimpleITK.StochasticFractalDimension(image);
   public static Image StochasticFractalDimension(this Image image, Image maskImage) => SimpleITK.StochasticFractalDimension(image, maskImage);
   public static Image StochasticFractalDimension(this Image image, Image maskImage, VectorUInt32 neighborhoodRadius) => SimpleITK.StochasticFractalDimension(image, maskImage, neighborhoodRadius);
   public static Image StochasticFractalDimension(this Image image, VectorUInt32 neighborhoodRadius) => SimpleITK.StochasticFractalDimension(image, neighborhoodRadius);
   public static Image Subtract(this double constant, Image image2) => SimpleITK.Subtract(constant, image2);
   public static Image Subtract(this Image image1, double constant) => SimpleITK.Subtract(image1, constant);
   public static Image Subtract(this Image image1, Image image2) => SimpleITK.Subtract(image1, image2);
   public static Image SumProjection(this Image image1) => SimpleITK.SumProjection(image1);
   public static Image SumProjection(this Image image1, uint projectionDimension) => SimpleITK.SumProjection(image1, projectionDimension);
   public static Image Tan(this Image image1) => SimpleITK.Tan(image1);
   public static Image TernaryAdd(this Image image1, Image image2, Image image3) => SimpleITK.TernaryAdd(image1, image2, image3);
   public static Image TernaryMagnitude(this Image image1, Image image2, Image image3) => SimpleITK.TernaryMagnitude(image1, image2, image3);
   public static Image TernaryMagnitudeSquared(this Image image1, Image image2, Image image3) => SimpleITK.TernaryMagnitudeSquared(image1, image2, image3);
   public static Image Threshold(this Image image1) => SimpleITK.Threshold(image1);
   public static Image Threshold(this Image image1, double lower) => SimpleITK.Threshold(image1, lower);
   public static Image Threshold(this Image image1, double lower, double upper) => SimpleITK.Threshold(image1, lower, upper);
   public static Image Threshold(this Image image1, double lower, double upper, double outsideValue) => SimpleITK.Threshold(image1, lower, upper, outsideValue);
   public static Image ThresholdMaximumConnectedComponents(this Image image1) => SimpleITK.ThresholdMaximumConnectedComponents(image1);
   public static Image ThresholdMaximumConnectedComponents(this Image image1, uint minimumObjectSizeInPixels) => SimpleITK.ThresholdMaximumConnectedComponents(image1, minimumObjectSizeInPixels);
   public static Image ThresholdMaximumConnectedComponents(this Image image1, uint minimumObjectSizeInPixels, double upperBoundary) => SimpleITK.ThresholdMaximumConnectedComponents(image1, minimumObjectSizeInPixels, upperBoundary);
   public static Image ThresholdMaximumConnectedComponents(this Image image1, uint minimumObjectSizeInPixels, double upperBoundary, byte insideValue) => SimpleITK.ThresholdMaximumConnectedComponents(image1, minimumObjectSizeInPixels, upperBoundary, insideValue);
   public static Image ThresholdMaximumConnectedComponents(this Image image1, uint minimumObjectSizeInPixels, double upperBoundary, byte insideValue, byte outsideValue) => SimpleITK.ThresholdMaximumConnectedComponents(image1, minimumObjectSizeInPixels, upperBoundary, insideValue, outsideValue);
   public static Image ThresholdSegmentationLevelSet(this Image initialImage, Image featureImage) => SimpleITK.ThresholdSegmentationLevelSet(initialImage, featureImage);
   public static Image ThresholdSegmentationLevelSet(this Image initialImage, Image featureImage, double lowerThreshold) => SimpleITK.ThresholdSegmentationLevelSet(initialImage, featureImage, lowerThreshold);
   public static Image ThresholdSegmentationLevelSet(this Image initialImage, Image featureImage, double lowerThreshold, double upperThreshold) => SimpleITK.ThresholdSegmentationLevelSet(initialImage, featureImage, lowerThreshold, upperThreshold);
   public static Image ThresholdSegmentationLevelSet(this Image initialImage, Image featureImage, double lowerThreshold, double upperThreshold, double maximumRMSError) => SimpleITK.ThresholdSegmentationLevelSet(initialImage, featureImage, lowerThreshold, upperThreshold, maximumRMSError);
   public static Image ThresholdSegmentationLevelSet(this Image initialImage, Image featureImage, double lowerThreshold, double upperThreshold, double maximumRMSError, double propagationScaling) => SimpleITK.ThresholdSegmentationLevelSet(initialImage, featureImage, lowerThreshold, upperThreshold, maximumRMSError, propagationScaling);
   public static Image ThresholdSegmentationLevelSet(this Image initialImage, Image featureImage, double lowerThreshold, double upperThreshold, double maximumRMSError, double propagationScaling, double curvatureScaling) => SimpleITK.ThresholdSegmentationLevelSet(initialImage, featureImage, lowerThreshold, upperThreshold, maximumRMSError, propagationScaling, curvatureScaling);
   public static Image ThresholdSegmentationLevelSet(this Image initialImage, Image featureImage, double lowerThreshold, double upperThreshold, double maximumRMSError, double propagationScaling, double curvatureScaling, uint numberOfIterations) => SimpleITK.ThresholdSegmentationLevelSet(initialImage, featureImage, lowerThreshold, upperThreshold, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations);
   public static Image ThresholdSegmentationLevelSet(this Image initialImage, Image featureImage, double lowerThreshold, double upperThreshold, double maximumRMSError, double propagationScaling, double curvatureScaling, uint numberOfIterations, bool reverseExpansionDirection) => SimpleITK.ThresholdSegmentationLevelSet(initialImage, featureImage, lowerThreshold, upperThreshold, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations, reverseExpansionDirection);
   public static Image TikhonovDeconvolution(this Image image1, Image image2) => SimpleITK.TikhonovDeconvolution(image1, image2);
   public static Image TikhonovDeconvolution(this Image image1, Image image2, double regularizationConstant) => SimpleITK.TikhonovDeconvolution(image1, image2, regularizationConstant);
   public static Image TikhonovDeconvolution(this Image image1, Image image2, double regularizationConstant, bool normalize) => SimpleITK.TikhonovDeconvolution(image1, image2, regularizationConstant, normalize);
   public static Image TikhonovDeconvolution(this Image image1, Image image2, double regularizationConstant, bool normalize, TikhonovDeconvolutionImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.TikhonovDeconvolution(image1, image2, regularizationConstant, normalize, boundaryCondition);
   public static Image TikhonovDeconvolution(this Image image1, Image image2, double regularizationConstant, bool normalize, TikhonovDeconvolutionImageFilter.BoundaryConditionType boundaryCondition, TikhonovDeconvolutionImageFilter.OutputRegionModeType outputRegionMode) => SimpleITK.TikhonovDeconvolution(image1, image2, regularizationConstant, normalize, boundaryCondition, outputRegionMode);
   public static Image Tile(this Image image1) => SimpleITK.Tile(image1);
   public static Image Tile(this Image image1, Image image2) => SimpleITK.Tile(image1, image2);
   public static Image Tile(this Image image1, Image image2, Image image3) => SimpleITK.Tile(image1, image2, image3);
   public static Image Tile(this Image image1, Image image2, Image image3, Image image4) => SimpleITK.Tile(image1, image2, image3, image4);
   public static Image Tile(this Image image1, Image image2, Image image3, Image image4, Image image5) => SimpleITK.Tile(image1, image2, image3, image4, image5);
   public static Image Tile(this Image image1, Image image2, Image image3, Image image4, Image image5, VectorUInt32 layout) => SimpleITK.Tile(image1, image2, image3, image4, image5, layout);
   public static Image Tile(this Image image1, Image image2, Image image3, Image image4, Image image5, VectorUInt32 layout, double defaultPixelValue) => SimpleITK.Tile(image1, image2, image3, image4, image5, layout, defaultPixelValue);
   public static Image Tile(this Image image1, Image image2, Image image3, Image image4, VectorUInt32 layout) => SimpleITK.Tile(image1, image2, image3, image4, layout);
   public static Image Tile(this Image image1, Image image2, Image image3, Image image4, VectorUInt32 layout, double defaultPixelValue) => SimpleITK.Tile(image1, image2, image3, image4, layout, defaultPixelValue);
   public static Image Tile(this Image image1, Image image2, Image image3, VectorUInt32 layout) => SimpleITK.Tile(image1, image2, image3, layout);
   public static Image Tile(this Image image1, Image image2, Image image3, VectorUInt32 layout, double defaultPixelValue) => SimpleITK.Tile(image1, image2, image3, layout, defaultPixelValue);
   public static Image Tile(this Image image1, Image image2, VectorUInt32 layout) => SimpleITK.Tile(image1, image2, layout);
   public static Image Tile(this Image image1, Image image2, VectorUInt32 layout, double defaultPixelValue) => SimpleITK.Tile(image1, image2, layout, defaultPixelValue);
   public static Image Tile(this Image image1, VectorUInt32 layout) => SimpleITK.Tile(image1, layout);
   public static Image Tile(this Image image1, VectorUInt32 layout, double defaultPixelValue) => SimpleITK.Tile(image1, layout, defaultPixelValue);
   public static Image Tile(this VectorOfImage images) => SimpleITK.Tile(images);
   public static Image Tile(this VectorOfImage images, VectorUInt32 layout) => SimpleITK.Tile(images, layout);
   public static Image Tile(this VectorOfImage images, VectorUInt32 layout, double defaultPixelValue) => SimpleITK.Tile(images, layout, defaultPixelValue);
   public static Image Toboggan(this Image image1) => SimpleITK.Toboggan(image1);
   public static Image TransformGeometry(this Image image, Transform transform) => SimpleITK.TransformGeometry(image, transform);
   public static Image TransformToDisplacementField(this Transform transform) => SimpleITK.TransformToDisplacementField(transform);
   public static Image TransformToDisplacementField(this Transform transform, PixelIDValueEnum outputPixelType) => SimpleITK.TransformToDisplacementField(transform, outputPixelType);
   public static Image TransformToDisplacementField(this Transform transform, PixelIDValueEnum outputPixelType, VectorUInt32 size) => SimpleITK.TransformToDisplacementField(transform, outputPixelType, size);
   public static Image TransformToDisplacementField(this Transform transform, PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble outputOrigin) => SimpleITK.TransformToDisplacementField(transform, outputPixelType, size, outputOrigin);
   public static Image TransformToDisplacementField(this Transform transform, PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble outputOrigin, VectorDouble outputSpacing) => SimpleITK.TransformToDisplacementField(transform, outputPixelType, size, outputOrigin, outputSpacing);
   public static Image TransformToDisplacementField(this Transform transform, PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection) => SimpleITK.TransformToDisplacementField(transform, outputPixelType, size, outputOrigin, outputSpacing, outputDirection);
   public static Image TriangleThreshold(this Image image) => SimpleITK.TriangleThreshold(image);
   public static Image TriangleThreshold(this Image image, byte insideValue) => SimpleITK.TriangleThreshold(image, insideValue);
   public static Image TriangleThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.TriangleThreshold(image, insideValue, outsideValue);
   public static Image TriangleThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.TriangleThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image TriangleThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.TriangleThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image TriangleThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.TriangleThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image TriangleThreshold(this Image image, Image maskImage) => SimpleITK.TriangleThreshold(image, maskImage);
   public static Image TriangleThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.TriangleThreshold(image, maskImage, insideValue);
   public static Image TriangleThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.TriangleThreshold(image, maskImage, insideValue, outsideValue);
   public static Image TriangleThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.TriangleThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image TriangleThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.TriangleThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image TriangleThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.TriangleThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image UnaryMinus(this Image image1) => SimpleITK.UnaryMinus(image1);
   public static Image UnsharpMask(this Image image1) => SimpleITK.UnsharpMask(image1);
   public static Image UnsharpMask(this Image image1, VectorDouble sigmas) => SimpleITK.UnsharpMask(image1, sigmas);
   public static Image UnsharpMask(this Image image1, VectorDouble sigmas, double amount) => SimpleITK.UnsharpMask(image1, sigmas, amount);
   public static Image UnsharpMask(this Image image1, VectorDouble sigmas, double amount, double threshold) => SimpleITK.UnsharpMask(image1, sigmas, amount, threshold);
   public static Image UnsharpMask(this Image image1, VectorDouble sigmas, double amount, double threshold, bool clamp) => SimpleITK.UnsharpMask(image1, sigmas, amount, threshold, clamp);
   public static Image ValuedRegionalMaxima(this Image image1) => SimpleITK.ValuedRegionalMaxima(image1);
   public static Image ValuedRegionalMaxima(this Image image1, bool fullyConnected) => SimpleITK.ValuedRegionalMaxima(image1, fullyConnected);
   public static Image ValuedRegionalMinima(this Image image1) => SimpleITK.ValuedRegionalMinima(image1);
   public static Image ValuedRegionalMinima(this Image image1, bool fullyConnected) => SimpleITK.ValuedRegionalMinima(image1, fullyConnected);
   public static Image VectorConfidenceConnected(this Image image1) => SimpleITK.VectorConfidenceConnected(image1);
   public static Image VectorConfidenceConnected(this Image image1, VectorUIntList seedList) => SimpleITK.VectorConfidenceConnected(image1, seedList);
   public static Image VectorConfidenceConnected(this Image image1, VectorUIntList seedList, uint numberOfIterations) => SimpleITK.VectorConfidenceConnected(image1, seedList, numberOfIterations);
   public static Image VectorConfidenceConnected(this Image image1, VectorUIntList seedList, uint numberOfIterations, double multiplier) => SimpleITK.VectorConfidenceConnected(image1, seedList, numberOfIterations, multiplier);
   public static Image VectorConfidenceConnected(this Image image1, VectorUIntList seedList, uint numberOfIterations, double multiplier, uint initialNeighborhoodRadius) => SimpleITK.VectorConfidenceConnected(image1, seedList, numberOfIterations, multiplier, initialNeighborhoodRadius);
   public static Image VectorConfidenceConnected(this Image image1, VectorUIntList seedList, uint numberOfIterations, double multiplier, uint initialNeighborhoodRadius, byte replaceValue) => SimpleITK.VectorConfidenceConnected(image1, seedList, numberOfIterations, multiplier, initialNeighborhoodRadius, replaceValue);
   public static Image VectorConnectedComponent(this Image image1) => SimpleITK.VectorConnectedComponent(image1);
   public static Image VectorConnectedComponent(this Image image1, double distanceThreshold) => SimpleITK.VectorConnectedComponent(image1, distanceThreshold);
   public static Image VectorConnectedComponent(this Image image1, double distanceThreshold, bool fullyConnected) => SimpleITK.VectorConnectedComponent(image1, distanceThreshold, fullyConnected);
   public static Image VectorIndexSelectionCast(this Image image1) => SimpleITK.VectorIndexSelectionCast(image1);
   public static Image VectorIndexSelectionCast(this Image image1, uint index) => SimpleITK.VectorIndexSelectionCast(image1, index);
   public static Image VectorIndexSelectionCast(this Image image1, uint index, PixelIDValueEnum outputPixelType) => SimpleITK.VectorIndexSelectionCast(image1, index, outputPixelType);
   public static Image VectorMagnitude(this Image image1) => SimpleITK.VectorMagnitude(image1);
   public static Image VotingBinary(this Image image1) => SimpleITK.VotingBinary(image1);
   public static Image VotingBinary(this Image image1, VectorUInt32 radius) => SimpleITK.VotingBinary(image1, radius);
   public static Image VotingBinary(this Image image1, VectorUInt32 radius, uint birthThreshold) => SimpleITK.VotingBinary(image1, radius, birthThreshold);
   public static Image VotingBinary(this Image image1, VectorUInt32 radius, uint birthThreshold, uint survivalThreshold) => SimpleITK.VotingBinary(image1, radius, birthThreshold, survivalThreshold);
   public static Image VotingBinary(this Image image1, VectorUInt32 radius, uint birthThreshold, uint survivalThreshold, double foregroundValue) => SimpleITK.VotingBinary(image1, radius, birthThreshold, survivalThreshold, foregroundValue);
   public static Image VotingBinary(this Image image1, VectorUInt32 radius, uint birthThreshold, uint survivalThreshold, double foregroundValue, double backgroundValue) => SimpleITK.VotingBinary(image1, radius, birthThreshold, survivalThreshold, foregroundValue, backgroundValue);
   public static Image VotingBinaryHoleFilling(this Image image1) => SimpleITK.VotingBinaryHoleFilling(image1);
   public static Image VotingBinaryHoleFilling(this Image image1, VectorUInt32 radius) => SimpleITK.VotingBinaryHoleFilling(image1, radius);
   public static Image VotingBinaryHoleFilling(this Image image1, VectorUInt32 radius, uint majorityThreshold) => SimpleITK.VotingBinaryHoleFilling(image1, radius, majorityThreshold);
   public static Image VotingBinaryHoleFilling(this Image image1, VectorUInt32 radius, uint majorityThreshold, double foregroundValue) => SimpleITK.VotingBinaryHoleFilling(image1, radius, majorityThreshold, foregroundValue);
   public static Image VotingBinaryHoleFilling(this Image image1, VectorUInt32 radius, uint majorityThreshold, double foregroundValue, double backgroundValue) => SimpleITK.VotingBinaryHoleFilling(image1, radius, majorityThreshold, foregroundValue, backgroundValue);
   public static Image VotingBinaryIterativeHoleFilling(this Image image1) => SimpleITK.VotingBinaryIterativeHoleFilling(image1);
   public static Image VotingBinaryIterativeHoleFilling(this Image image1, VectorUInt32 radius) => SimpleITK.VotingBinaryIterativeHoleFilling(image1, radius);
   public static Image VotingBinaryIterativeHoleFilling(this Image image1, VectorUInt32 radius, uint maximumNumberOfIterations) => SimpleITK.VotingBinaryIterativeHoleFilling(image1, radius, maximumNumberOfIterations);
   public static Image VotingBinaryIterativeHoleFilling(this Image image1, VectorUInt32 radius, uint maximumNumberOfIterations, uint majorityThreshold) => SimpleITK.VotingBinaryIterativeHoleFilling(image1, radius, maximumNumberOfIterations, majorityThreshold);
   public static Image VotingBinaryIterativeHoleFilling(this Image image1, VectorUInt32 radius, uint maximumNumberOfIterations, uint majorityThreshold, double foregroundValue) => SimpleITK.VotingBinaryIterativeHoleFilling(image1, radius, maximumNumberOfIterations, majorityThreshold, foregroundValue);
   public static Image VotingBinaryIterativeHoleFilling(this Image image1, VectorUInt32 radius, uint maximumNumberOfIterations, uint majorityThreshold, double foregroundValue, double backgroundValue) => SimpleITK.VotingBinaryIterativeHoleFilling(image1, radius, maximumNumberOfIterations, majorityThreshold, foregroundValue, backgroundValue);
   public static Image Warp(this Image image, Image displacementField) => SimpleITK.Warp(image, displacementField);
   public static Image Warp(this Image image, Image displacementField, InterpolatorEnum interpolator) => SimpleITK.Warp(image, displacementField, interpolator);
   public static Image Warp(this Image image, Image displacementField, InterpolatorEnum interpolator, VectorUInt32 outputSize) => SimpleITK.Warp(image, displacementField, interpolator, outputSize);
   public static Image Warp(this Image image, Image displacementField, InterpolatorEnum interpolator, VectorUInt32 outputSize, VectorDouble outputOrigin) => SimpleITK.Warp(image, displacementField, interpolator, outputSize, outputOrigin);
   public static Image Warp(this Image image, Image displacementField, InterpolatorEnum interpolator, VectorUInt32 outputSize, VectorDouble outputOrigin, VectorDouble outputSpacing) => SimpleITK.Warp(image, displacementField, interpolator, outputSize, outputOrigin, outputSpacing);
   public static Image Warp(this Image image, Image displacementField, InterpolatorEnum interpolator, VectorUInt32 outputSize, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection) => SimpleITK.Warp(image, displacementField, interpolator, outputSize, outputOrigin, outputSpacing, outputDirection);
   public static Image Warp(this Image image, Image displacementField, InterpolatorEnum interpolator, VectorUInt32 outputSize, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection, double edgePaddingValue) => SimpleITK.Warp(image, displacementField, interpolator, outputSize, outputOrigin, outputSpacing, outputDirection, edgePaddingValue);
   public static Image WhiteTopHat(this Image image1) => SimpleITK.WhiteTopHat(image1);
   public static Image WhiteTopHat(this Image image1, VectorUInt32 kernelRadius) => SimpleITK.WhiteTopHat(image1, kernelRadius);
   public static Image WhiteTopHat(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType) => SimpleITK.WhiteTopHat(image1, kernelRadius, kernelType);
   public static Image WhiteTopHat(this Image image1, VectorUInt32 kernelRadius, KernelEnum kernelType, bool safeBorder) => SimpleITK.WhiteTopHat(image1, kernelRadius, kernelType, safeBorder);
   public static Image WienerDeconvolution(this Image image1, Image image2) => SimpleITK.WienerDeconvolution(image1, image2);
   public static Image WienerDeconvolution(this Image image1, Image image2, double noiseVariance) => SimpleITK.WienerDeconvolution(image1, image2, noiseVariance);
   public static Image WienerDeconvolution(this Image image1, Image image2, double noiseVariance, bool normalize) => SimpleITK.WienerDeconvolution(image1, image2, noiseVariance, normalize);
   public static Image WienerDeconvolution(this Image image1, Image image2, double noiseVariance, bool normalize, WienerDeconvolutionImageFilter.BoundaryConditionType boundaryCondition) => SimpleITK.WienerDeconvolution(image1, image2, noiseVariance, normalize, boundaryCondition);
   public static Image WienerDeconvolution(this Image image1, Image image2, double noiseVariance, bool normalize, WienerDeconvolutionImageFilter.BoundaryConditionType boundaryCondition, WienerDeconvolutionImageFilter.OutputRegionModeType outputRegionMode) => SimpleITK.WienerDeconvolution(image1, image2, noiseVariance, normalize, boundaryCondition, outputRegionMode);
   public static Image WrapPad(this Image image1) => SimpleITK.WrapPad(image1);
   public static Image WrapPad(this Image image1, VectorUInt32 padLowerBound) => SimpleITK.WrapPad(image1, padLowerBound);
   public static Image WrapPad(this Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) => SimpleITK.WrapPad(image1, padLowerBound, padUpperBound);
   public static Image Xor(this Image image1, Image image2) => SimpleITK.Xor(image1, image2);
   public static Image Xor(this Image image1, int constant) => SimpleITK.Xor(image1, constant);
   public static Image Xor(this int constant, Image image2) => SimpleITK.Xor(constant, image2);
   public static Image YenThreshold(this Image image) => SimpleITK.YenThreshold(image);
   public static Image YenThreshold(this Image image, byte insideValue) => SimpleITK.YenThreshold(image, insideValue);
   public static Image YenThreshold(this Image image, byte insideValue, byte outsideValue) => SimpleITK.YenThreshold(image, insideValue, outsideValue);
   public static Image YenThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.YenThreshold(image, insideValue, outsideValue, numberOfHistogramBins);
   public static Image YenThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.YenThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image YenThreshold(this Image image, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.YenThreshold(image, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image YenThreshold(this Image image, Image maskImage) => SimpleITK.YenThreshold(image, maskImage);
   public static Image YenThreshold(this Image image, Image maskImage, byte insideValue) => SimpleITK.YenThreshold(image, maskImage, insideValue);
   public static Image YenThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue) => SimpleITK.YenThreshold(image, maskImage, insideValue, outsideValue);
   public static Image YenThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins) => SimpleITK.YenThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins);
   public static Image YenThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput) => SimpleITK.YenThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput);
   public static Image YenThreshold(this Image image, Image maskImage, byte insideValue, byte outsideValue, uint numberOfHistogramBins, bool maskOutput, byte maskValue) => SimpleITK.YenThreshold(image, maskImage, insideValue, outsideValue, numberOfHistogramBins, maskOutput, maskValue);
   public static Image ZeroCrossing(this Image image1) => SimpleITK.ZeroCrossing(image1);
   public static Image ZeroCrossing(this Image image1, byte foregroundValue) => SimpleITK.ZeroCrossing(image1, foregroundValue);
   public static Image ZeroCrossing(this Image image1, byte foregroundValue, byte backgroundValue) => SimpleITK.ZeroCrossing(image1, foregroundValue, backgroundValue);
   public static Image ZeroCrossingBasedEdgeDetection(this Image image1) => SimpleITK.ZeroCrossingBasedEdgeDetection(image1);
   public static Image ZeroCrossingBasedEdgeDetection(this Image image1, double variance) => SimpleITK.ZeroCrossingBasedEdgeDetection(image1, variance);
   public static Image ZeroCrossingBasedEdgeDetection(this Image image1, double variance, byte foregroundValue) => SimpleITK.ZeroCrossingBasedEdgeDetection(image1, variance, foregroundValue);
   public static Image ZeroCrossingBasedEdgeDetection(this Image image1, double variance, byte foregroundValue, byte backgroundValue) => SimpleITK.ZeroCrossingBasedEdgeDetection(image1, variance, foregroundValue, backgroundValue);
   public static Image ZeroCrossingBasedEdgeDetection(this Image image1, double variance, byte foregroundValue, byte backgroundValue, double maximumError) => SimpleITK.ZeroCrossingBasedEdgeDetection(image1, variance, foregroundValue, backgroundValue, maximumError);
   public static Image ZeroFluxNeumannPad(this Image image1) => SimpleITK.ZeroFluxNeumannPad(image1);
   public static Image ZeroFluxNeumannPad(this Image image1, VectorUInt32 padLowerBound) => SimpleITK.ZeroFluxNeumannPad(image1, padLowerBound);
   public static Image ZeroFluxNeumannPad(this Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) => SimpleITK.ZeroFluxNeumannPad(image1, padLowerBound, padUpperBound);
   public static string GetPixelIDValueAsString(this PixelIDValueEnum type) => SimpleITK.GetPixelIDValueAsString(type);
   public static string Hash(this Image image) => SimpleITK.Hash(image);
   public static string Hash(this Image image, HashImageFilter.HashFunction function) => SimpleITK.Hash(image, function);
   public static void Show(this Image image) => SimpleITK.Show(image);
   public static void Show(this Image image, string title) => SimpleITK.Show(image, title);
   public static void Show(this Image image, string title, bool debugOn) => SimpleITK.Show(image, title, debugOn);
   public static void WriteImage(this Image image, string fileName) => SimpleITK.WriteImage(image, fileName);
   public static void WriteImage(this Image image, string fileName, bool useCompression) => SimpleITK.WriteImage(image, fileName, useCompression);
   public static void WriteImage(this Image image, string fileName, bool useCompression, int compressionLevel) => SimpleITK.WriteImage(image, fileName, useCompression, compressionLevel);
   public static void WriteImage(this Image image, VectorString fileNames) => SimpleITK.WriteImage(image, fileNames);
   public static void WriteImage(this Image image, VectorString fileNames, bool useCompression) => SimpleITK.WriteImage(image, fileNames, useCompression);
   public static void WriteImage(this Image image, VectorString fileNames, bool useCompression, int compressionLevel) => SimpleITK.WriteImage(image, fileNames, useCompression, compressionLevel);

}
